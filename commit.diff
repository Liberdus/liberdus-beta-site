diff --git a/otc/assets/1.png b/otc/assets/1.png
deleted file mode 100644
index 168fa4a..0000000
Binary files a/otc/assets/1.png and /dev/null differ
diff --git a/otc/css/components/cleanup.css b/otc/css/components/cleanup.css
deleted file mode 100644
index 0b6674c..0000000
--- a/otc/css/components/cleanup.css
+++ /dev/null
@@ -1,65 +0,0 @@
-.cleanup-container {
-    padding: 2rem;
-}
-
-.cleanup-section {
-    max-width: 600px;
-    margin: 0 auto;
-    background: var(--card-bg);
-    border-radius: 12px;
-    padding: 2rem;
-    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
-}
-
-.cleanup-info {
-    margin: 1.5rem 0;
-    color: var(--text-secondary);
-}
-
-.cleanup-stats {
-    margin-top: 1rem;
-    padding: 1rem;
-    background: var(--bg-secondary);
-    border-radius: 8px;
-    display: grid;
-    grid-template-columns: 1fr 1fr;
-    gap: 1rem;
-}
-
-.cleanup-category {
-    display: flex;
-    flex-direction: column;
-    gap: 0.5rem;
-}
-
-.cleanup-total {
-    grid-column: 1 / -1;
-    margin-top: 1rem;
-    padding-top: 1rem;
-    border-top: 1px solid var(--border-color);
-    text-align: center;
-    display: flex;
-    flex-direction: column;
-    align-items: center;
-    gap: 0.5rem;
-}
-
-.cleanup-total h3 {
-    color: var(--text-primary);
-    margin-bottom: 0.5rem;
-}
-
-.cleanup-stats span {
-    font-weight: bold;
-    color: var(--text-primary);
-}
-
-#cleanup-button {
-    width: 100%;
-    margin-top: 1.5rem;
-}
-
-#cleanup-button:disabled {
-    opacity: 0.6;
-    cursor: not-allowed;
-} 
\ No newline at end of file
diff --git a/otc/css/components/forms.css b/otc/css/components/forms.css
deleted file mode 100644
index aef8759..0000000
--- a/otc/css/components/forms.css
+++ /dev/null
@@ -1,389 +0,0 @@
-.form-container {
-  max-width: 480px;
-  margin: 0 auto;
-  padding: 24px;
-  background: #ffffff;
-  border-radius: 16px;
-  box-shadow: 0px 4px 20px rgba(0, 0, 0, 0.05);
-}
-
-.form-group {
-  margin-bottom: 20px;
-  background: #f8f9fe;
-  padding: 16px;
-  border-radius: 12px;
-}
-
-.form-group label {
-  display: block;
-  margin-bottom: 8px;
-  font-weight: 500;
-  color: #666666;
-}
-
-.form-group input {
-  width: 100%;
-  padding: 12px;
-  border: 1px solid #e8ecf4;
-  border-radius: 12px;
-  font-size: 16px;
-  background: #ffffff;
-  transition: border-color 0.2s;
-  box-sizing: border-box;
-  margin: 0;
-}
-
-.form-group input:focus {
-  outline: none;
-  border-color: #4b6bfb;
-  box-shadow: 0 0 0 1px #4b6bfb;
-}
-
-.action-button {
-  background-color: #4b6bfb;
-  color: white;
-  padding: 16px;
-  border: none;
-  border-radius: 12px;
-  cursor: pointer;
-  width: 100%;
-  font-size: 16px;
-  font-weight: 600;
-  transition: background-color 0.2s;
-}
-
-.action-button:hover {
-  background-color: #3a54d6;
-}
-
-.action-button:disabled {
-  background-color: #cccccc;
-  cursor: not-allowed;
-  opacity: 0.7;
-}
-
-/* Status message styling */
-.status {
-  margin-top: 20px;
-  padding: 16px;
-  border-radius: 12px;
-  text-align: center;
-}
-
-.status.error {
-  background-color: #fef3f2;
-  color: #b91c1c;
-}
-
-.status.success {
-  background-color: #f0f7ff;
-  color: #4b6bfb;
-}
-
-/* Token symbol display */
-#sellTokenSymbol,
-#buyTokenSymbol {
-  margin-left: 10px;
-  color: #7780a0;
-  font-size: 14px;
-}
-
-.form-group input[type="number"] {
-  /* Remove default number input styling */
-  -moz-appearance: textfield;
-}
-
-/* Remove spinner buttons for number inputs */
-.form-group input[type="number"]::-webkit-outer-spin-button,
-.form-group input[type="number"]::-webkit-inner-spin-button {
-  -webkit-appearance: none;
-  margin: 0;
-}
-
-.input-with-button {
-  display: flex;
-  gap: 8px;
-}
-
-.paste-button {
-  padding: 0 12px;
-  background: #4b6bfb;
-  color: white;
-  border: none;
-  border-radius: 8px;
-  cursor: pointer;
-  font-size: 14px;
-}
-
-.paste-button:hover {
-  background: #3a54d6;
-}
-
-.swap-container {
-  max-width: 480px;
-  margin: 20px auto;
-  padding: 0 16px;
-}
-
-.swap-header {
-  display: flex;
-  justify-content: space-between;
-  align-items: center;
-  margin-bottom: 16px;
-}
-
-.swap-header h2 {
-  font-size: 16px;
-  font-weight: 500;
-  color: #1a1a1a;
-}
-
-.settings-icon {
-  cursor: pointer;
-  padding: 8px;
-  border-radius: 8px;
-}
-
-.settings-icon:hover {
-  background: rgba(0, 0, 0, 0.05);
-}
-
-.swap-box {
-  background: white;
-  border-radius: 16px;
-  padding: 16px;
-  box-shadow: 0px 0px 1px rgba(0, 0, 0, 0.01), 0px 4px 8px rgba(0, 0, 0, 0.04),
-    0px 16px 24px rgba(0, 0, 0, 0.04), 0px 24px 32px rgba(0, 0, 0, 0.01);
-}
-
-.input-box {
-  margin-bottom: 4px;
-  padding: 16px;
-  border-radius: 12px;
-  background: #f7f8fa;
-}
-
-.input-box label {
-  display: block;
-  font-size: 14px;
-  color: #7d7d7d;
-  margin-bottom: 8px;
-}
-
-.input-container {
-  display: flex;
-  align-items: center;
-}
-
-.token-input-container {
-  display: flex;
-  justify-content: space-between;
-  align-items: center;
-  gap: 12px;
-}
-
-.input-box input {
-  background: transparent;
-  border: none;
-  font-size: 24px;
-  width: 100%;
-  outline: none;
-  color: #1a1a1a;
-}
-
-.input-box input::placeholder {
-  color: #bdbdbd;
-}
-
-.token-selector {
-  display: flex;
-  align-items: center;
-  padding: 4px 8px;
-  background: white;
-  border: 1px solid #e8e8e8;
-  border-radius: 16px;
-  cursor: pointer;
-  gap: 8px;
-}
-
-.token-selector:hover {
-  background: #f7f8fa;
-}
-
-.dropdown-arrow {
-  font-size: 12px;
-  color: #7d7d7d;
-}
-
-.balance-text {
-  font-size: 12px;
-  color: #7d7d7d;
-  margin-top: 4px;
-  display: block;
-}
-
-.swap-arrow {
-  display: flex;
-  justify-content: center;
-  margin: 4px 0;
-  color: #7d7d7d;
-  font-size: 20px;
-}
-
-.fee-container {
-  margin-top: 16px;
-  padding: 12px;
-  background: #f7f8fa;
-  border-radius: 12px;
-  display: flex;
-  justify-content: space-between;
-  font-size: 14px;
-  color: #7d7d7d;
-}
-
-.create-order-button {
-  width: 100%;
-  margin-top: 16px;
-  padding: 16px;
-  background: #4b6bfb;
-  color: white;
-  border: none;
-  border-radius: 12px;
-  font-size: 16px;
-  font-weight: 600;
-  cursor: pointer;
-  transition: background 0.2s;
-}
-
-.create-order-button:hover {
-  background: #3a59fa;
-}
-
-.create-order-button:disabled {
-  background: #e8e8e8;
-  cursor: not-allowed;
-}
-
-.placeholder-text {
-  color: #666;
-  font-style: italic;
-}
-
-/* Order action buttons */
-.fill-button,
-.cancel-button {
-  padding: 8px 16px;
-  border-radius: 8px;
-  font-size: 14px;
-  font-weight: 500;
-  cursor: pointer;
-  border: none;
-  transition: background-color 0.2s, opacity 0.2s;
-}
-
-.fill-button {
-  background-color: #4b6bfb;
-  color: white;
-}
-
-.fill-button:hover {
-  background-color: #3a54d6;
-}
-
-.cancel-button {
-  background-color: #dc2626;
-  color: white;
-}
-
-.cancel-button:hover {
-  background-color: #b91c1c;
-}
-
-.fill-button:disabled,
-.cancel-button:disabled {
-  opacity: 0.5;
-  cursor: not-allowed;
-}
-
-.your-order {
-  color: #666666;
-  font-style: italic;
-  font-size: 14px;
-}
-
-.fee-group {
-  position: relative;
-}
-
-.info-tooltip {
-  position: relative;
-  display: inline-flex;
-  align-items: center;
-  margin-left: 5px;
-  cursor: help;
-}
-
-.info-tooltip svg {
-  color: #666;
-  transition: color 0.2s;
-}
-
-.info-tooltip:hover svg {
-  color: #333;
-}
-
-.tooltip-text {
-  visibility: hidden;
-  position: absolute;
-  bottom: 100%;
-  left: 50%;
-  transform: translateX(-50%);
-  width: 300px;
-  padding: 12px;
-  background-color: #333;
-  color: white;
-  text-align: left;
-  line-height: 1.5;
-  z-index: 1;
-  opacity: 0;
-  transition: opacity 0.2s;
-}
-
-.tooltip-text strong {
-  color: #fff;
-  display: block;
-  margin-bottom: 4px;
-}
-
-.info-tooltip:hover .tooltip-text {
-  visibility: visible;
-  opacity: 1;
-}
-
-.fee-details {
-  display: flex;
-  flex-direction: column;
-  gap: 4px;
-}
-
-.fee-amount {
-  font-size: 16px;
-  font-weight: 500;
-}
-
-.fee-gas {
-  font-size: 14px;
-  color: #666;
-}
-
-/* Add arrow to tooltip */
-.tooltip-text::after {
-  content: "";
-  position: absolute;
-  top: 100%;
-  left: 50%;
-  margin-left: -5px;
-  border-width: 5px;
-  border-style: solid;
-  border-color: #333 transparent transparent transparent;
-}
diff --git a/otc/css/components/orders.css b/otc/css/components/orders.css
deleted file mode 100644
index e32975c..0000000
--- a/otc/css/components/orders.css
+++ /dev/null
@@ -1,315 +0,0 @@
-/* Table container */
-.table-container {
-  width: 100%;
-  overflow-x: auto;
-  margin-bottom: 1.25rem;
-  border-radius: 0.75rem;
-  box-shadow: 0 0.125rem 0.5rem rgba(0, 0, 0, 0.1);
-  padding: 0.5rem;
-}
-
-/* Table base styles */
-.orders-table {
-  width: 100%;
-  border-collapse: collapse;
-  background: #ffffff;
-  table-layout: fixed;
-  min-width: 56rem;
-}
-
-.orders-table thead {
-  background-color: #f8f9fe;
-}
-
-/* Column widths - with wider ID column */
-.orders-table th:nth-child(1) {
-  width: 7%;
-} /* ID */
-.orders-table th:nth-child(2) {
-  width: 11%;
-} /* Buy Token */
-.orders-table th:nth-child(3) {
-  width: 11%;
-} /* Buy Amount */
-.orders-table th:nth-child(4) {
-  width: 11%;
-} /* Sell Token */
-.orders-table th:nth-child(5) {
-  width: 11%;
-} /* Sell Amount */
-.orders-table th:nth-child(6) {
-  width: 12%;
-} /* Expires */
-.orders-table th:nth-child(7) {
-  width: 12%;
-} /* Status */
-.orders-table th:nth-child(8) {
-  width: 12%;
-} /* Maker */
-.orders-table th:nth-child(9) {
-  width: 13%;
-} /* Action */
-
-/* Cell styles */
-.orders-table th,
-.orders-table td {
-  padding: 0.75rem;
-  text-align: left;
-  white-space: nowrap;
-  overflow: hidden;
-  text-overflow: ellipsis;
-  font-size: 0.875rem;
-}
-
-/* Status column specific styles */
-.order-status {
-  font-weight: 500;
-}
-
-/* Action column specific styles */
-.action-column {
-  text-align: center;
-}
-
-/* Fill button styles */
-.fill-button {
-  background-color: #10b981;
-  color: white;
-  padding: 0.5rem 1rem;
-  border: none;
-  border-radius: 0.5rem;
-  font-weight: 500;
-  cursor: pointer;
-  transition: all 0.2s ease;
-  font-size: 0.875rem;
-  text-align: center;
-  min-width: 6rem;
-  box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
-}
-
-.fill-button:hover {
-  background-color: #059669;
-  transform: translateY(-1px);
-}
-
-.fill-button:active {
-  transform: translateY(0);
-}
-
-/* Your order text style */
-.your-order {
-  color: #6b7280;
-  font-size: 0.875rem;
-  font-weight: 500;
-}
-
-/* Open order and targeted order styles */
-.open-order,
-.targeted-order {
-  font-size: 0.875rem;
-  color: #6b7280;
-}
-
-.targeted-order {
-  cursor: help;
-}
-
-/* Responsive adjustments */
-@media (max-width: 1024px) {
-  .orders-table {
-    font-size: 0.9em;
-  }
-}
-
-/* Sorting styles */
-th[data-sort] {
-  cursor: pointer;
-  user-select: none;
-  position: relative;
-}
-
-th[data-sort]:hover {
-  background-color: rgba(0, 0, 0, 0.05);
-}
-
-.sort-icon {
-  display: inline-block;
-  margin-left: 4px;
-  opacity: 0.5;
-  font-size: 1rem;
-}
-
-/* Active sort state */
-th[data-sort].active-sort {
-  background-color: rgba(0, 0, 0, 0.03);
-}
-
-th[data-sort].active-sort .sort-icon {
-  opacity: 1;
-  color: #10b981; /* Using your existing green color */
-}
-
-/* Filter and Pagination Controls */
-.filter-controls {
-  margin-bottom: 1rem;
-  padding: 1rem;
-  background-color: #f8f9fe;
-  border-radius: 0.75rem;
-  box-shadow: 0 0.125rem 0.5rem rgba(0, 0, 0, 0.1);
-}
-
-.filter-controls.bottom-controls {
-  margin-top: 1rem;
-  margin-bottom: 0;
-}
-
-.filter-row {
-  display: flex;
-  justify-content: space-between;
-  align-items: center;
-  gap: 1.5rem;
-}
-
-/* Filter Toggle */
-.filter-toggle {
-  display: flex;
-  align-items: center;
-  gap: 0.5rem;
-  cursor: pointer;
-  font-size: 0.875rem;
-  color: #6b7280;
-}
-
-.filter-toggle input[type="checkbox"] {
-  cursor: pointer;
-  width: 1rem;
-  height: 1rem;
-  border-radius: 0.25rem;
-  border: 2px solid #10b981;
-  accent-color: #10b981;
-}
-
-.filter-toggle:hover {
-  color: #4b5563;
-}
-
-/* Pagination Controls */
-.pagination-controls {
-  display: flex;
-  align-items: center;
-  gap: 1.5rem;
-  margin-left: auto;
-}
-
-/* Page Size Select */
-.page-size-select {
-  padding: 0.5rem 2rem 0.5rem 1rem;
-  border-radius: 0.5rem;
-  border: 1px solid #e5e7eb;
-  background-color: white;
-  color: #374151;
-  font-size: 0.875rem;
-  cursor: pointer;
-  transition: all 0.2s ease;
-  appearance: none;
-  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%236B7280'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'%3E%3C/path%3E%3C/svg%3E");
-  background-repeat: no-repeat;
-  background-position: right 0.75rem center;
-  background-size: 1rem;
-}
-
-.page-size-select:hover {
-  border-color: #10b981;
-}
-
-.page-size-select:focus {
-  outline: none;
-  border-color: #10b981;
-  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
-}
-
-/* Pagination Buttons */
-.pagination-buttons {
-  display: flex;
-  align-items: center;
-  gap: 0.75rem;
-}
-
-.pagination-button {
-  display: inline-flex;
-  align-items: center;
-  justify-content: center;
-  width: 2rem;
-  height: 2rem;
-  border-radius: 0.375rem;
-  border: 1px solid #e5e7eb;
-  background-color: white;
-  color: #374151;
-  font-size: 1rem;
-  cursor: pointer;
-  transition: all 0.15s ease;
-  padding: 0;
-}
-
-.pagination-button:hover:not(:disabled) {
-  background-color: #f9fafb;
-  border-color: #10b981;
-  color: #10b981;
-}
-
-.pagination-button:disabled {
-  background-color: #f3f4f6;
-  color: #9ca3af;
-  cursor: not-allowed;
-  border-color: #e5e7eb;
-}
-
-.pagination-arrow {
-  font-size: 1rem;
-  line-height: 1;
-}
-
-/* Page Info */
-.page-info {
-  font-size: 0.875rem;
-  color: #6b7280;
-  min-width: 5rem;
-  text-align: center;
-  font-weight: 500;
-}
-
-/* Responsive adjustments */
-@media (max-width: 768px) {
-  .filter-row {
-    flex-direction: column;
-    align-items: stretch;
-  }
-
-  .pagination-controls {
-    flex-direction: column;
-    gap: 1rem;
-  }
-
-  .pagination-buttons {
-    justify-content: center;
-  }
-
-  .page-size-select {
-    width: 100%;
-  }
-}
-
-/* Zebra striping for rows */
-.orders-table tbody tr:nth-child(even) {
-    background-color: #f9fafb;  /* Very light gray with slight blue tint */
-}
-
-.orders-table tbody tr:nth-child(odd) {
-    background-color: #ffffff;  /* White */
-}
-
-/* Hover effect for rows */
-.orders-table tbody tr:hover {
-    background-color: #f3f4f6;  /* Slightly darker on hover */
-    transition: background-color 0.15s ease-in-out;
-}
diff --git a/otc/css/components/tabs.css b/otc/css/components/tabs.css
deleted file mode 100644
index 1d8155c..0000000
--- a/otc/css/components/tabs.css
+++ /dev/null
@@ -1,64 +0,0 @@
-.nav-tabs {
-    display: flex;
-    gap: 24px;
-    margin: 32px 0;
-    padding: 0 24px;
-    border-bottom: 2px solid #e9ecef;
-    justify-content: center;
-    align-items: center;
-    width: 100%;
-    background: white;
-}
-
-.tab-button {
-    padding: 12px 28px;
-    border: none;
-    background: none;
-    cursor: pointer;
-    font-weight: 600;
-    color: #64748b;
-    position: relative;
-    white-space: nowrap;
-    transition: all 0.3s ease;
-}
-
-.tab-button:hover {
-    color: #4B6BFB;
-}
-
-.tab-button.active {
-    color: #4B6BFB;
-}
-
-.tab-button::after {
-    content: '';
-    position: absolute;
-    bottom: -2px;
-    left: 0;
-    width: 100%;
-    height: 2px;
-    background-color: #4B6BFB;
-    transform: scaleX(0);
-    transition: transform 0.3s ease;
-}
-
-.tab-button.active::after {
-    transform: scaleX(1);
-}
-
-.tab-content {
-    display: none;
-    padding: 24px;
-    margin: 24px;
-    background: white;
-    border-radius: 16px;
-    opacity: 0;
-    transform: translateY(10px);
-    transition: all 0.3s ease;
-}
-
-.tab-content.active {
-    display: block;
-    opacity: 1;
-    transform: translateY(0);
-}
diff --git a/otc/css/components/wallet.css b/otc/css/components/wallet.css
deleted file mode 100644
index 076da77..0000000
--- a/otc/css/components/wallet.css
+++ /dev/null
@@ -1,191 +0,0 @@
-.wallet-container {
-  display: flex;
-  align-items: center;
-  gap: 12px;
-  position: relative;
-}
-
-.network-selector {
-  position: relative;
-}
-
-.network-button {
-  display: flex;
-  align-items: center;
-  gap: 6px;
-  padding: 8px 12px;
-  background: var(--background-secondary);
-  border: 1px solid var(--border-color);
-  border-radius: 12px;
-  color: var(--text-primary);
-  cursor: pointer;
-  transition: all 0.2s ease;
-}
-
-.network-button:hover {
-  background: var(--background-hover);
-}
-
-.network-dropdown {
-  position: absolute;
-  top: calc(100% + 4px);
-  right: 0;
-  background: var(--background-secondary);
-  border: 1px solid var(--border-color);
-  border-radius: 12px;
-  padding: 4px;
-  min-width: 150px;
-  z-index: 1000;
-  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
-}
-
-.network-dropdown.hidden {
-  display: none;
-}
-
-.network-option {
-  display: flex;
-  align-items: center;
-  padding: 8px 12px;
-  cursor: pointer;
-  border-radius: 8px;
-  transition: all 0.2s ease;
-}
-
-.wallet-button {
-  display: flex;
-  align-items: center;
-  gap: 8px;
-  padding: 8px 16px;
-  background: #4b6bfb;
-  border: none;
-  border-radius: 12px;
-  color: white;
-  font-weight: 600;
-  cursor: pointer;
-  transition: background 0.2s ease;
-}
-
-.wallet-button:hover {
-  background: #3a54d6;
-}
-
-.wallet-info {
-  display: flex;
-  align-items: center;
-  gap: 8px;
-  background: #f8f9fa;
-  padding: 8px 12px;
-  border-radius: 12px;
-  border: 1px solid #e9ecef;
-  min-width: 200px;
-  justify-content: space-between;
-}
-
-.wallet-info.hidden {
-  display: none !important;
-}
-
-.account-address {
-  font-family: monospace;
-  font-size: 14px;
-  color: #666;
-  margin-right: 0;
-  flex: 1;
-}
-
-.wallet-disconnect {
-  display: flex;
-  align-items: center;
-  gap: 8px;
-  padding: 8px 16px;
-  background: #f44336;
-  border: none;
-  border-radius: 12px;
-  color: white;
-  font-weight: 600;
-  cursor: pointer;
-  transition: background 0.2s ease;
-}
-
-.wallet-disconnect:hover {
-  background: #d32f2f;
-}
-
-.wallet-disconnect svg {
-  width: 16px;
-  height: 16px;
-  stroke: currentColor;
-  stroke-width: 2;
-}
-
-.chevron-down {
-  transition: transform 0.2s ease;
-}
-
-.network-button:hover .chevron-down {
-  transform: rotate(180deg);
-}
-
-.hidden {
-  display: none !important;
-}
-
-.network-button.single-network {
-  cursor: default;
-}
-
-.network-button.single-network:hover {
-  background: var(--background-secondary);
-}
-
-.network-button.single-network .chevron-down {
-  display: none;
-}
-
-.network-badge {
-  display: inline-flex;
-  align-items: center;
-  padding: 4px 10px;
-  font-size: 14px;
-  font-weight: 600;
-  color: white;
-  margin-right: 8px;
-  transition: all 0.2s ease;
-  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
-  letter-spacing: normal;
-  border-radius: 20px;
-  position: relative;
-}
-
-.network-badge::before {
-  content: '';
-  display: inline-block;
-  width: 6px;
-  height: 6px;
-  border-radius: 50%;
-  margin-right: 6px;
-  background-color: currentColor;
-  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
-}
-
-.network-badge.connected {
-  background-color: rgba(16, 185, 129, 0.15);
-  color: #10b981;
-}
-
-.network-badge.wrong-network {
-  background-color: rgba(239, 68, 68, 0.15);
-  color: #ef4444;
-}
-
-.network-button:hover .network-badge {
-  transform: none;
-  box-shadow: none;
-}
-
-.network-button.single-network {
-  background: transparent;
-  border: none;
-  padding: 0;
-}
diff --git a/otc/css/styles.css b/otc/css/styles.css
deleted file mode 100644
index 7abf881..0000000
--- a/otc/css/styles.css
+++ /dev/null
@@ -1,118 +0,0 @@
-/* Base styles */
-body {
-    background-color: #f7f8fa;
-    color: #1a1a1a;
-    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
-        "Helvetica Neue", Arial, sans-serif;
-    margin: 0;
-}
-
-.container {
-    max-width: 1200px;
-    margin: 0 auto;
-    padding: 20px;
-}
-
-/* Header styles */
-.header {
-    display: flex;
-    justify-content: space-between;
-    align-items: center;
-    padding: 1rem 2rem;
-    background-color: #f8f9fa;
-    border-bottom: 1px solid #e9ecef;
-}
-
-.header-left .logo-container {
-    display: flex;
-    align-items: center;
-    gap: 12px;
-}
-
-.logo-image {
-    height: 32px;
-    width: auto;
-    object-fit: contain;
-}
-
-.header-left h1 {
-    margin: 0;
-    font-size: 32px;
-    color: #1a1a1a;
-    font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
-    font-weight: 600;
-    letter-spacing: -0.5px;
-    line-height: 32px;
-}
-
-.header-right {
-    display: flex;
-    align-items: center;
-    gap: 1rem;
-}
-
-.network-badge {
-    padding: 4px 8px;
-    border-radius: 12px;
-    font-size: 12px;
-    margin-right: 8px;
-    background-color: #666;
-    color: white;
-}
-
-.network-badge.connected {
-    background-color: #4CAF50;
-}
-
-.network-badge.wrong-network {
-    background-color: #f44336;
-}
-
-.hidden {
-    display: none !important;
-}
-
-.main-content {
-    max-width: 1200px;
-    margin: 0 auto;
-    padding: 20px;
-}
-
-.content-wrapper {
-    background: white;
-    border-radius: 16px;
-    box-shadow: 0px 4px 20px rgba(0, 0, 0, 0.05);
-    margin-top: 20px;
-    overflow: hidden;
-}
-
-.tab-content-wrapper {
-    padding: 20px;
-    text-align: center;
-}
-
-.tab-content-wrapper h2 {
-    margin-bottom: 16px;
-    color: #333;
-}
-
-.tab-content-wrapper p {
-    color: #666;
-}
-
-/* Example of browser-specific fixes */
-* {
-    margin: 0;
-    padding: 0;
-    box-sizing: border-box;
-    -webkit-font-smoothing: antialiased;
-    -moz-osx-font-smoothing: grayscale;
-}
-
-/* Firefox-specific styles */
-@-moz-document url-prefix() {
-    /* Add Firefox-specific rules here */
-}
-
-/* Add Inter font */
-@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');
diff --git a/otc/index.html b/otc/index.html
deleted file mode 100644
index 123ab62..0000000
--- a/otc/index.html
+++ /dev/null
@@ -1,254 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-  <!-- Head -->
-  <head>
-    <meta charset="UTF-8" />
-    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
-    <title>OTC Swap</title>
-    <!-- Normalize.css -->
-    <link
-      rel="stylesheet"
-      href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"
-    />
-    <!-- Styles -->
-    <link rel="stylesheet" href="css/styles.css" />
-    <!-- Components -->
-    <link rel="stylesheet" href="css/components/header.css" />
-    <link rel="stylesheet" href="css/components/network.css" />
-    <link rel="stylesheet" href="css/components/content.css" />
-    <link rel="stylesheet" href="css/components/forms.css" />
-    <link rel="stylesheet" href="css/components/orders.css" />
-    <link rel="stylesheet" href="css/components/tabs.css" />
-    <link rel="stylesheet" href="css/components/wallet.css" />
-    <link rel="stylesheet" href="css/components/cleanup.css" />
-    <link rel="stylesheet" href="css/components/debug.css" />
-    <!-- Script -->
-    <script type="importmap">
-      {
-        "imports": {
-          "ethers": "https://unpkg.com/ethers@5.7.2/dist/ethers.esm.min.js"
-        }
-      }
-    </script>
-    <!-- App -->
-    <script type="module" src="js/app.js" defer></script>
-  </head>
-  <!-- Body -->
-  <body>
-    <div class="container">
-      <!-- Header -->
-      <header class="header">
-        <!-- Header Left -->
-        <div class="header-left">
-          <div class="logo-container">
-            <img src="assets/1.png" alt="LiberSwap Logo" class="logo-image">
-            <h1>LiberOTCSwap</h1>
-            <span class="version">v1.0.2</span>
-          </div>
-        </div>
-        <!-- Header Right -->
-        <div class="header-right">
-          <div id="wallet-container" class="wallet-container">
-            <div class="network-selector">
-              <button class="network-button">
-                <span class="network-badge">Amoy</span>
-                <svg
-                  class="chevron-down"
-                  width="12"
-                  height="12"
-                  viewBox="0 0 24 24"
-                  fill="none"
-                  stroke="currentColor"
-                >
-                  <path
-                    d="M6 9l6 6 6-6"
-                    stroke-width="2"
-                    stroke-linecap="round"
-                    stroke-linejoin="round"
-                  />
-                </svg>
-              </button>
-              <!-- Network Dropdown -->
-              <div class="network-dropdown hidden">
-                <!-- Network options will be populated dynamically -->
-              </div>
-            </div>
-            <!-- Wallet Connect Button -->
-            <button id="walletConnect" class="wallet-button">
-              <span class="wallet-button-text">Connect Wallet</span>
-            </button>
-            <!-- Wallet Info -->
-            <div id="walletInfo" class="wallet-info hidden">
-              <span id="accountAddress" class="account-address"></span>
-              <!-- Wallet Disconnect Button -->
-              <button id="walletDisconnect" class="wallet-disconnect">
-                <svg
-                  width="16"
-                  height="16"
-                  viewBox="0 0 24 24"
-                  fill="none"
-                  stroke="currentColor"
-                >
-                  <path
-                    d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"
-                    stroke-width="2"
-                    stroke-linecap="round"
-                  />
-                  <path
-                    d="M16 17l5-5-5-5"
-                    stroke-width="2"
-                    stroke-linecap="round"
-                  />
-                  <path d="M21 12H9" stroke-width="2" stroke-linecap="round" />
-                </svg>
-              </button>
-            </div>
-          </div>
-        </div>
-      </header>
-      <!-- Debug Panel -->
-      <div class="debug-panel" style="display: none">
-        <div class="debug-controls">
-          <h3>Debug Settings</h3>
-          <!-- Select All Checkbox -->
-          <label>
-            <input type="checkbox" id="selectAll" /> Select All
-          </label>
-          <label><input type="checkbox" data-debug="APP" /> App</label>
-          <label><input type="checkbox" data-debug="WEBSOCKET" /> WebSocket</label>
-          <label><input type="checkbox" data-debug="COMPONENTS" /> Components</label>
-          <label><input type="checkbox" data-debug="WALLET" /> Wallet</label>
-          <label><input type="checkbox" data-debug="VIEW_ORDERS" /> View Orders</label>
-          <label><input type="checkbox" data-debug="CREATE_ORDER" /> Create Order</label>
-          <label><input type="checkbox" data-debug="MY_ORDERS" /> My Orders</label>
-          <label><input type="checkbox" data-debug="TAKER_ORDERS" /> Taker Orders</label>
-          <label><input type="checkbox" data-debug="CLEANUP_ORDERS" /> Cleanup Orders</label>
-          <label><input type="checkbox" data-debug="WALLET_UI" /> Wallet UI</label>
-          <button id="applyDebug">Apply</button>
-        </div>
-      </div>
-      <!-- Main Content -->
-      <main class="main-content">
-        <div class="content-wrapper">
-          <nav class="nav-tabs">
-            <button class="tab-button active" data-tab="create-order">
-              Create Order
-            </button>
-            <button class="tab-button" data-tab="view-orders">
-              View Orders
-            </button>
-            <button class="tab-button" data-tab="my-orders">My Orders</button>
-            <button class="tab-button" data-tab="taker-orders">
-              Invited Orders
-            </button>
-            <button class="tab-button" data-tab="cleanup-orders">
-              Cleanup
-            </button>
-          </nav>
-
-          <div id="create-order" class="tab-content active">
-            <div class="form-container">
-              <div class="swap-box">
-                <h2>Create OTC Swap Order</h2>
-                <div class="form-group">
-                  <label>
-                    Partner Address (optional):
-                    <span class="info-tooltip">
-                      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
-                        <circle cx="12" cy="12" r="10" stroke-width="2"/>
-                        <path d="M12 16v-4" stroke-width="2" stroke-linecap="round"/>
-                        <circle cx="12" cy="8" r="1" fill="currentColor"/>
-                      </svg>
-                      <span class="tooltip-text">
-                        <strong>Partner Address:</strong> If you want only a specific address to be able to fill this order, enter their wallet address here. Leave empty to allow anyone to fill the order.
-                        <br><br>
-                        💡 Use this for private trades with a specific trading partner.
-                      </span>
-                    </span>
-                  </label>
-                  <input type="text" id="partner" placeholder="0x..." />
-                </div>
-                <div class="form-group">
-                  <label for="sellToken">Sell Token Address:</label>
-                  <input type="text" id="sellToken" placeholder="0x..." />
-                  <span id="sellTokenBalance"></span>
-                </div>
-                <div class="form-group">
-                  <label for="sellAmount">Sell Amount:</label>
-                  <input
-                    type="text"
-                    id="sellAmount"
-                    placeholder="Enter amount"
-                  />
-                </div>
-                <div class="form-group">
-                  <label for="buyToken">Buy Token Address:</label>
-                  <input type="text" id="buyToken" placeholder="0x..." />
-                  <span id="buyTokenBalance"></span>
-                </div>
-                <div class="form-group">
-                  <label for="buyAmount">Buy Amount:</label>
-                  <input
-                    type="text"
-                    id="buyAmount"
-                    placeholder="Enter amount"
-                  />
-                </div>
-                <div class="form-group fee-group">
-                  <label>
-                    Order Creation Fee:
-                    <span class="info-tooltip">
-                      <svg
-                        width="16"
-                        height="16"
-                        viewBox="0 0 24 24"
-                        fill="none"
-                        stroke="currentColor"
-                      >
-                        <circle cx="12" cy="12" r="10" stroke-width="2" />
-                        <path
-                          d="M12 16v-4"
-                          stroke-width="2"
-                          stroke-linecap="round"
-                        />
-                        <circle cx="12" cy="8" r="1" fill="currentColor" />
-                      </svg>
-                      <span class="tooltip-text">
-                        <strong>Order Creation Fee:</strong> A small fee in POL
-                        is required to create an order. This prevents spam and
-                        rewards users who help clean up expired orders.
-                        <br /><br />
-                        <strong>Average Gas:</strong> This number represents the
-                        typical computational cost to process an order on the
-                        blockchain. The creation fee is automatically adjusted
-                        based on this value to ensure fair pricing regardless of
-                        network conditions. <br /><br />
-                        💡 For example: If gas is 100,000, the fee will be
-                        approximately 0.00001 POL.
-                      </span>
-                    </span>
-                  </label>
-                  <span id="orderCreationFee" class="placeholder-text"
-                    >Connect wallet to view fee</span
-                  >
-                </div>
-                <button class="action-button" id="createOrderBtn" disabled>
-                  Connect Wallet to Create Order
-                </button>
-                <div id="status" class="status"></div>
-              </div>
-            </div>
-          </div>
-          <div id="view-orders" class="tab-content"></div>
-          <div id="my-orders" class="tab-content"></div>
-          <div id="taker-orders" class="tab-content"></div>
-          <div id="cleanup-orders" class="tab-content">
-            <div id="cleanup-container" class="cleanup-container">
-              <!-- Cleanup component will populate this -->
-            </div>
-          </div>
-        </div>
-      </main>
-    </div>
-  </body>
-</html>
diff --git a/otc/js/abi/OTCSwap.js b/otc/js/abi/OTCSwap.js
deleted file mode 100644
index b9df67b..0000000
--- a/otc/js/abi/OTCSwap.js
+++ /dev/null
@@ -1,595 +0,0 @@
-export const abi = [
-  {
-    "inputs": [],
-    "stateMutability": "nonpayable",
-    "type": "constructor"
-  },
-  {
-    "inputs": [],
-    "name": "ReentrancyGuardReentrantCall",
-    "type": "error"
-  },
-  {
-    "inputs": [
-      {
-        "internalType": "address",
-        "name": "token",
-        "type": "address"
-      }
-    ],
-    "name": "SafeERC20FailedOperation",
-    "type": "error"
-  },
-  {
-    "anonymous": false,
-    "inputs": [
-      {
-        "indexed": true,
-        "internalType": "uint256",
-        "name": "orderId",
-        "type": "uint256"
-      },
-      {
-        "indexed": false,
-        "internalType": "string",
-        "name": "reason",
-        "type": "string"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "timestamp",
-        "type": "uint256"
-      }
-    ],
-    "name": "CleanupError",
-    "type": "event"
-  },
-  {
-    "anonymous": false,
-    "inputs": [
-      {
-        "indexed": true,
-        "internalType": "address",
-        "name": "recipient",
-        "type": "address"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "amount",
-        "type": "uint256"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "timestamp",
-        "type": "uint256"
-      }
-    ],
-    "name": "CleanupFeesDistributed",
-    "type": "event"
-  },
-  {
-    "anonymous": false,
-    "inputs": [
-      {
-        "indexed": true,
-        "internalType": "uint256",
-        "name": "orderId",
-        "type": "uint256"
-      },
-      {
-        "indexed": true,
-        "internalType": "address",
-        "name": "maker",
-        "type": "address"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "timestamp",
-        "type": "uint256"
-      }
-    ],
-    "name": "OrderCanceled",
-    "type": "event"
-  },
-  {
-    "anonymous": false,
-    "inputs": [
-      {
-        "indexed": true,
-        "internalType": "uint256",
-        "name": "orderId",
-        "type": "uint256"
-      },
-      {
-        "indexed": true,
-        "internalType": "address",
-        "name": "maker",
-        "type": "address"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "timestamp",
-        "type": "uint256"
-      }
-    ],
-    "name": "OrderCleanedUp",
-    "type": "event"
-  },
-  {
-    "anonymous": false,
-    "inputs": [
-      {
-        "indexed": true,
-        "internalType": "uint256",
-        "name": "orderId",
-        "type": "uint256"
-      },
-      {
-        "indexed": true,
-        "internalType": "address",
-        "name": "maker",
-        "type": "address"
-      },
-      {
-        "indexed": true,
-        "internalType": "address",
-        "name": "taker",
-        "type": "address"
-      },
-      {
-        "indexed": false,
-        "internalType": "address",
-        "name": "sellToken",
-        "type": "address"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "sellAmount",
-        "type": "uint256"
-      },
-      {
-        "indexed": false,
-        "internalType": "address",
-        "name": "buyToken",
-        "type": "address"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "buyAmount",
-        "type": "uint256"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "timestamp",
-        "type": "uint256"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "orderCreationFee",
-        "type": "uint256"
-      }
-    ],
-    "name": "OrderCreated",
-    "type": "event"
-  },
-  {
-    "anonymous": false,
-    "inputs": [
-      {
-        "indexed": true,
-        "internalType": "uint256",
-        "name": "orderId",
-        "type": "uint256"
-      },
-      {
-        "indexed": true,
-        "internalType": "address",
-        "name": "maker",
-        "type": "address"
-      },
-      {
-        "indexed": true,
-        "internalType": "address",
-        "name": "taker",
-        "type": "address"
-      },
-      {
-        "indexed": false,
-        "internalType": "address",
-        "name": "sellToken",
-        "type": "address"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "sellAmount",
-        "type": "uint256"
-      },
-      {
-        "indexed": false,
-        "internalType": "address",
-        "name": "buyToken",
-        "type": "address"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "buyAmount",
-        "type": "uint256"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "timestamp",
-        "type": "uint256"
-      }
-    ],
-    "name": "OrderFilled",
-    "type": "event"
-  },
-  {
-    "anonymous": false,
-    "inputs": [
-      {
-        "indexed": true,
-        "internalType": "uint256",
-        "name": "oldOrderId",
-        "type": "uint256"
-      },
-      {
-        "indexed": true,
-        "internalType": "uint256",
-        "name": "newOrderId",
-        "type": "uint256"
-      },
-      {
-        "indexed": true,
-        "internalType": "address",
-        "name": "maker",
-        "type": "address"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "tries",
-        "type": "uint256"
-      },
-      {
-        "indexed": false,
-        "internalType": "uint256",
-        "name": "timestamp",
-        "type": "uint256"
-      }
-    ],
-    "name": "RetryOrder",
-    "type": "event"
-  },
-  {
-    "inputs": [],
-    "name": "FEE_DAMPENING_FACTOR",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "inputs": [],
-    "name": "GRACE_PERIOD",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "inputs": [],
-    "name": "MAX_CLEANUP_BATCH",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "inputs": [],
-    "name": "MAX_FEE_PERCENTAGE",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "inputs": [],
-    "name": "MAX_RETRY_ATTEMPTS",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "inputs": [],
-    "name": "MIN_FEE_PERCENTAGE",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "inputs": [],
-    "name": "ORDER_EXPIRY",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "inputs": [],
-    "name": "accumulatedFees",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "inputs": [
-      {
-        "internalType": "contract IERC20",
-        "name": "token",
-        "type": "address"
-      },
-      {
-        "internalType": "address",
-        "name": "to",
-        "type": "address"
-      },
-      {
-        "internalType": "uint256",
-        "name": "amount",
-        "type": "uint256"
-      }
-    ],
-    "name": "attemptTransfer",
-    "outputs": [],
-    "stateMutability": "nonpayable",
-    "type": "function"
-  },
-  {
-    "inputs": [],
-    "name": "averageGasUsed",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "inputs": [
-      {
-        "internalType": "uint256",
-        "name": "orderId",
-        "type": "uint256"
-      }
-    ],
-    "name": "cancelOrder",
-    "outputs": [],
-    "stateMutability": "nonpayable",
-    "type": "function"
-  },
-  {
-    "inputs": [],
-    "name": "cleanupExpiredOrders",
-    "outputs": [],
-    "stateMutability": "nonpayable",
-    "type": "function"
-  },
-  {
-    "inputs": [
-      {
-        "internalType": "address",
-        "name": "taker",
-        "type": "address"
-      },
-      {
-        "internalType": "address",
-        "name": "sellToken",
-        "type": "address"
-      },
-      {
-        "internalType": "uint256",
-        "name": "sellAmount",
-        "type": "uint256"
-      },
-      {
-        "internalType": "address",
-        "name": "buyToken",
-        "type": "address"
-      },
-      {
-        "internalType": "uint256",
-        "name": "buyAmount",
-        "type": "uint256"
-      }
-    ],
-    "name": "createOrder",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "payable",
-    "type": "function"
-  },
-  {
-    "inputs": [
-      {
-        "internalType": "uint256",
-        "name": "orderId",
-        "type": "uint256"
-      }
-    ],
-    "name": "fillOrder",
-    "outputs": [],
-    "stateMutability": "nonpayable",
-    "type": "function"
-  },
-  {
-    "inputs": [],
-    "name": "firstOrderId",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "inputs": [],
-    "name": "nextOrderId",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "inputs": [],
-    "name": "orderCreationFee",
-    "outputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "inputs": [
-      {
-        "internalType": "uint256",
-        "name": "",
-        "type": "uint256"
-      }
-    ],
-    "name": "orders",
-    "outputs": [
-      {
-        "internalType": "address",
-        "name": "maker",
-        "type": "address"
-      },
-      {
-        "internalType": "address",
-        "name": "taker",
-        "type": "address"
-      },
-      {
-        "internalType": "address",
-        "name": "sellToken",
-        "type": "address"
-      },
-      {
-        "internalType": "uint256",
-        "name": "sellAmount",
-        "type": "uint256"
-      },
-      {
-        "internalType": "address",
-        "name": "buyToken",
-        "type": "address"
-      },
-      {
-        "internalType": "uint256",
-        "name": "buyAmount",
-        "type": "uint256"
-      },
-      {
-        "internalType": "uint256",
-        "name": "timestamp",
-        "type": "uint256"
-      },
-      {
-        "internalType": "enum OTCSwap.OrderStatus",
-        "name": "status",
-        "type": "uint8"
-      },
-      {
-        "internalType": "uint256",
-        "name": "orderCreationFee",
-        "type": "uint256"
-      },
-      {
-        "internalType": "uint256",
-        "name": "tries",
-        "type": "uint256"
-      }
-    ],
-    "stateMutability": "view",
-    "type": "function"
-  },
-  {
-    "stateMutability": "payable",
-    "type": "receive"
-  }
-]; 
\ No newline at end of file
diff --git a/otc/js/abi/erc20.js b/otc/js/abi/erc20.js
deleted file mode 100644
index ee4f8ee..0000000
--- a/otc/js/abi/erc20.js
+++ /dev/null
@@ -1,8 +0,0 @@
-export const erc20Abi = [
-    "function name() external view returns (string)",
-    "function symbol() external view returns (string)",
-    "function decimals() external view returns (uint8)",
-    "function balanceOf(address account) external view returns (uint256)",
-    "function allowance(address owner, address spender) external view returns (uint256)",
-    "function approve(address spender, uint256 amount) external returns (bool)"
-]; 
\ No newline at end of file
diff --git a/otc/js/app.js b/otc/js/app.js
deleted file mode 100644
index f29e60f..0000000
--- a/otc/js/app.js
+++ /dev/null
@@ -1,455 +0,0 @@
-import { BaseComponent } from './components/BaseComponent.js';
-import { CreateOrder } from './components/CreateOrder.js';
-import { walletManager, WalletManager, getNetworkConfig, getAllNetworks, isDebugEnabled } from './config.js';
-import { WalletUI } from './components/WalletUI.js';
-import { WebSocketService } from './services/WebSocket.js';
-import { ViewOrders } from './components/ViewOrders.js';
-import { MyOrders } from './components/MyOrders.js';
-import { TakerOrders } from './components/TakerOrders.js';
-import { Cleanup } from './components/Cleanup.js';
-
-console.log('App.js loaded');
-
-class App {
-    constructor() {
-        this.debug = (message, ...args) => {
-            if (isDebugEnabled('APP')) {
-                console.log('[App]', message, ...args);
-            }
-        };
-
-        this.debug('App constructor called');
-        
-        this.walletUI = new WalletUI();
-        
-        this.handleConnectWallet = async (e) => {
-            e && e.preventDefault();
-            await this.connectWallet();
-        };
-
-        // Initialize components
-        this.components = {
-            'wallet-info': this.walletUI,
-            'view-orders': new ViewOrders(),
-            'my-orders': new MyOrders(),
-            'taker-orders': new TakerOrders(),
-            'cleanup-orders': new Cleanup()
-        };
-
-        // Render wallet UI immediately
-        this.walletUI.render();
-
-        // Handle other components
-        Object.entries(this.components).forEach(([id, component]) => {
-            if (component instanceof BaseComponent && 
-                !(component instanceof CreateOrder) && 
-                !(component instanceof ViewOrders) &&
-                !(component instanceof TakerOrders) &&
-                !(component instanceof WalletUI) &&
-                !(component instanceof Cleanup)) {
-                component.render = function() {
-                    if (!this.initialized) {
-                        this.container.innerHTML = `
-                            <div class="tab-content-wrapper">
-                                <h2>${this.container.id.split('-').map(word => 
-                                    word.charAt(0).toUpperCase() + word.slice(1)
-                                ).join(' ')}</h2>
-                                <p>Coming soon...</p>
-                            </div>
-                        `;
-                        this.initialized = true;
-                    }
-                };
-            }
-        });
-
-        this.currentTab = 'create-order';
-
-        // Add wallet connect button handler
-        const walletConnectBtn = document.getElementById('walletConnect');
-        if (walletConnectBtn) {
-            walletConnectBtn.addEventListener('click', this.handleConnectWallet);
-        }
-
-        // Add wallet connection state handler
-        walletManager.addListener((event, data) => {
-            if (event === 'connect') {
-                this.debug('Wallet connected, reinitializing components...');
-                this.updateTabVisibility(true);
-                this.reinitializeComponents();
-            } else if (event === 'disconnect') {
-                this.debug('Wallet disconnected, updating tab visibility...');
-                this.updateTabVisibility(false);
-            }
-        });
-
-        // Add tab switching event listeners
-        this.initializeEventListeners();
-
-        // Initialize cleanup component
-        const cleanup = new Cleanup();
-
-        // Add WebSocket event handlers for order updates
-        window.webSocket?.subscribe('OrderCreated', () => {
-            this.debug('Order created, refreshing components...');
-            this.refreshActiveComponent();
-        });
-
-        window.webSocket?.subscribe('OrderFilled', () => {
-            this.debug('Order filled, refreshing components...');
-            this.refreshActiveComponent();
-        });
-
-        window.webSocket?.subscribe('OrderCanceled', () => {
-            this.debug('Order canceled, refreshing components...');
-            this.refreshActiveComponent();
-        });
-
-        // Initialize debug panel
-        this.initializeDebugPanel();
-
-        // Add new method to update tab visibility
-        this.updateTabVisibility = (isConnected) => {
-            const tabButtons = document.querySelectorAll('.tab-button');
-            tabButtons.forEach(button => {
-                if (button.dataset.tab === 'create-order') return; // Always show create-order
-                button.style.display = isConnected ? 'block' : 'none';
-            });
-            
-            // If disconnected and not on create-order tab, switch to it
-            if (!isConnected && this.currentTab !== 'create-order') {
-                this.showTab('create-order');
-            }
-        };
-
-        // Update initial tab visibility
-        this.updateTabVisibility(false);
-    }
-
-    initializeEventListeners() {
-        // Add click handlers for tab buttons
-        document.querySelectorAll('.tab-button').forEach(button => {
-            button.addEventListener('click', (e) => {
-                const tabId = e.target.dataset.tab;
-                if (tabId) {
-                    this.showTab(tabId);
-                }
-            });
-        });
-    }
-
-    initializeDebugPanel() {
-        // Show debug panel with keyboard shortcut (Ctrl+Shift+D)
-        document.addEventListener('keydown', (e) => {
-            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
-                const panel = document.querySelector('.debug-panel');
-                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
-            }
-        });
-
-        // Initialize checkboxes from localStorage
-        const savedDebug = localStorage.getItem('debug');
-        if (savedDebug) {
-            const settings = JSON.parse(savedDebug);
-            document.querySelectorAll('[data-debug]').forEach(checkbox => {
-                checkbox.checked = settings[checkbox.dataset.debug] ?? false;
-            });
-        }
-
-        // Handle apply button
-        document.getElementById('applyDebug')?.addEventListener('click', () => {
-            const settings = {};
-            document.querySelectorAll('[data-debug]').forEach(checkbox => {
-                settings[checkbox.dataset.debug] = checkbox.checked;
-            });
-            localStorage.setItem('debug', JSON.stringify(settings));
-            location.reload(); // Reload to apply new debug settings
-        });
-    }
-
-    async initialize() {
-        try {
-            this.debug('Starting initialization...');
-            // Initialize wallet manager with autoConnect parameter
-            window.walletManager = walletManager;
-            await walletManager.init(true);
-            
-            // Initialize WebSocket service
-            window.webSocket = new WebSocketService();
-            const wsInitialized = await window.webSocket.initialize();
-            if (!wsInitialized) {
-                this.debug('WebSocket initialization failed, falling back to HTTP');
-            }
-            
-            // Initialize components in read-only mode initially
-            await this.initializeComponents(true);
-            
-            this.debug('Initialization complete');
-        } catch (error) {
-            this.debug('Initialization error:', error);
-        }
-    }
-
-    async initializeComponents(readOnlyMode) {
-        try {
-            this.debug('Initializing components in ' + 
-                (readOnlyMode ? 'read-only' : 'connected') + ' mode');
-            
-            // Initialize each component
-            for (const [id, component] of Object.entries(this.components)) {
-                if (component && typeof component.initialize === 'function') {
-                    this.debug(`Initializing component: ${id}`);
-                    try {
-                        await component.initialize(readOnlyMode);
-                    } catch (error) {
-                        // Log error but continue with other components
-                        console.error(`[App] Error initializing ${id}:`, error);
-                    }
-                }
-            }
-            
-            // Show the current tab
-            this.showTab(this.currentTab);
-            
-            this.debug('Components initialized');
-        } catch (error) {
-            console.error('[App] Error initializing components:', error);
-            // Continue execution instead of throwing
-            this.showError("Some components failed to initialize. Limited functionality available.");
-        }
-    }
-
-    async connectWallet() {
-        const loader = document.createElement('div');
-        loader.className = 'loader-overlay';
-        loader.innerHTML = '<div class="loader"></div>';
-        document.body.appendChild(loader);
-        
-        try {
-            await walletManager.connect();
-        } catch (error) {
-            this.showError("Failed to connect wallet: " + error.message);
-        } finally {
-            if (loader && loader.parentElement) {
-                loader.parentElement.removeChild(loader);
-            }
-        }
-    }
-
-    handleWalletConnect = async (account) => {
-        console.log('[App] Wallet connected:', account);
-        try {
-            await this.reinitializeComponents();
-            // Refresh the current tab view
-            this.showTab(this.currentTab);
-        } catch (error) {
-            console.error('[App] Error handling wallet connection:', error);
-        }
-    }
-
-    handleWalletDisconnect() {
-        const walletConnectBtn = document.getElementById('walletConnect');
-        const walletInfo = document.getElementById('walletInfo');
-        const accountAddress = document.getElementById('accountAddress');
-        
-        if (walletConnectBtn) {
-            walletConnectBtn.style.display = 'flex';
-        }
-        
-        if (walletInfo) {
-            walletInfo.classList.add('hidden');
-        }
-        
-        if (accountAddress) {
-            accountAddress.textContent = '';
-        }
-        
-        this.showSuccess("Wallet disconnected successfully");
-    }
-
-    handleAccountChange(account) {
-        
-    }
-
-    handleChainChange(chainId) {
-        
-    }
-
-    showLoader() {
-        const loader = document.createElement('div');
-        loader.className = 'loader-overlay';
-        loader.innerHTML = '<div class="loader"></div>';
-        document.body.appendChild(loader);
-        return loader;
-    }
-
-    hideLoader(loader) {
-        if (loader && loader.parentElement) {
-            loader.parentElement.removeChild(loader);
-        }
-    }
-
-    showError(message) {
-        const error = document.createElement('div');
-        error.className = 'status error';
-        error.textContent = message;
-        document.body.appendChild(error);
-        setTimeout(() => error.remove(), 5000);
-    }
-
-    showSuccess(message) {
-        const success = document.createElement('div');
-        success.className = 'status success';
-        success.textContent = message;
-        document.body.appendChild(success);
-        setTimeout(() => success.remove(), 5000);
-    }
-
-    async showTab(tabId) {
-        try {
-            this.debug('Switching to tab:', tabId);
-            
-            // Hide all tab content
-            document.querySelectorAll('.tab-content').forEach(tab => {
-                tab.classList.remove('active');
-            });
-            
-            // Update tab buttons
-            document.querySelectorAll('.tab-button').forEach(button => {
-                button.classList.remove('active');
-                if (button.dataset.tab === tabId) {
-                    button.classList.add('active');
-                }
-            });
-            
-            // Show selected tab
-            const tabContent = document.getElementById(tabId);
-            if (tabContent) {
-                tabContent.classList.add('active');
-                
-                // Initialize component if it exists
-                const component = this.components[tabId];
-                if (component?.initialize) {
-                    const readOnlyMode = !window.walletManager?.provider;
-                    await component.initialize(readOnlyMode);
-                }
-            }
-            
-            this.currentTab = tabId;
-            this.debug('Tab switch complete:', tabId);
-        } catch (error) {
-            console.error('[App] Error showing tab:', error);
-        }
-    }
-
-    // Add new method to reinitialize components
-    async reinitializeComponents() {
-        if (this.isReinitializing) {
-            this.debug('Already reinitializing, skipping...');
-            return;
-        }
-        this.isReinitializing = true;
-        
-        try {
-            this.debug('Reinitializing components with wallet...');
-            
-            // Create and initialize CreateOrder component when wallet is connected
-            const createOrderComponent = new CreateOrder();
-            this.components['create-order'] = createOrderComponent;
-            await createOrderComponent.initialize(false);
-            
-            // Reinitialize only the current tab's component
-            const currentComponent = this.components[this.currentTab];
-            if (currentComponent && typeof currentComponent.initialize === 'function') {
-                this.debug(`Reinitializing current component: ${this.currentTab}`);
-                try {
-                    await currentComponent.initialize(false);
-                } catch (error) {
-                    console.error(`[App] Error reinitializing ${this.currentTab}:`, error);
-                }
-            }
-
-            // Re-show the current tab
-            await this.showTab(this.currentTab);
-            
-            this.debug('Components reinitialized');
-        } finally {
-            this.isReinitializing = false;
-        }
-    }
-
-    // Add method to refresh active component
-    async refreshActiveComponent() {
-        const activeComponent = this.components[this.currentTab];
-        if (activeComponent?.initialize) {
-            this.debug('Refreshing active component:', this.currentTab);
-            await activeComponent.initialize(false);
-        }
-    }
-}
-
-// Initialize app when DOM is loaded
-document.addEventListener('DOMContentLoaded', async () => {
-    try {
-        window.app = new App();
-        window.app.initializeEventListeners();
-        window.app.showTab(window.app.currentTab);
-        
-        // Wait for wallet initialization to complete
-        await window.app.initialize().catch(error => {
-            console.error('[App] Failed to initialize wallet:', error);
-            throw error;
-        });
-        
-        window.app.debug('Initialization complete');
-    } catch (error) {
-        console.error('[App] App initialization error:', error);
-    }
-});
-
-// Network selector functionality
-const networkButton = document.querySelector('.network-button');
-const networkDropdown = document.querySelector('.network-dropdown');
-const networkBadge = document.querySelector('.network-badge');
-
-// Dynamically populate network options
-const populateNetworkOptions = () => {
-    const networks = getAllNetworks();
-    
-    // If only one network, hide dropdown functionality
-    if (networks.length <= 1) {
-        networkButton.classList.add('single-network');
-        return;
-    }
-    
-    networkDropdown.innerHTML = networks.map(network => `
-        <div class="network-option" data-network="${network.name.toLowerCase()}" data-chain-id="${network.chainId}">
-            ${network.displayName}
-        </div>
-    `).join('');
-    
-    // Re-attach click handlers only if multiple networks
-    document.querySelectorAll('.network-option').forEach(option => {
-        option.addEventListener('click', async () => {
-            try {
-                networkBadge.textContent = option.textContent;
-                networkDropdown.classList.add('hidden');
-                
-                if (window.walletManager && window.walletManager.isConnected()) {
-                    const chainId = option.dataset.chainId;
-                    await window.ethereum.request({
-                        method: 'wallet_switchEthereumChain',
-                        params: [{ chainId }],
-                    });
-                }
-            } catch (error) {
-                console.error('Failed to switch network:', error);
-                networkBadge.textContent = networkButton.querySelector('.network-badge').textContent;
-                app.showError('Failed to switch network: ' + error.message);
-            }
-        });
-    });
-};
-
-// Initialize network dropdown
-populateNetworkOptions();
diff --git a/otc/js/components/BaseComponent.js b/otc/js/components/BaseComponent.js
deleted file mode 100644
index 8ac15b0..0000000
--- a/otc/js/components/BaseComponent.js
+++ /dev/null
@@ -1,293 +0,0 @@
-import { walletManager } from '../config.js';
-import { ethers } from 'ethers';
-import { erc20Abi } from '../abi/erc20.js';
-import { isDebugEnabled } from '../config.js';
-
-console.log('BaseComponent.js loaded');
-
-export class BaseComponent {
-    constructor(containerId) {
-        // Define debug method first
-        this.debug = (message, ...args) => {
-            if (isDebugEnabled('BASE_COMPONENT')) {
-                console.log(`[${this.constructor.name}]`, message, ...args);
-            }
-        };
-
-        this.debug('Constructor called with:', containerId);
-        this.container = document.querySelector(`#${containerId}, .${containerId}`);
-        if (!this.container) {
-            throw new Error(`Container with id or class ${containerId} not found`);
-        }
-        
-        // Initialize the token cache
-        this.tokenCache = new Map();
-        // Initialize provider from window.walletManager if available
-        this.provider = window.walletManager?.provider || null;
-    }
-
-    createElement(tag, className = '', textContent = '') {
-        const element = document.createElement(tag);
-        if (className) element.className = className;
-        if (textContent) element.textContent = textContent;
-        return element;
-    }
-
-    showError(message) {
-        const errorDiv = document.createElement('div');
-        errorDiv.className = 'status error';
-        errorDiv.textContent = message;
-        this.container.appendChild(errorDiv);
-        setTimeout(() => errorDiv.remove(), 5000);
-    }
-
-    showSuccess(message) {
-        const successDiv = document.createElement('div');
-        successDiv.className = 'status success';
-        successDiv.textContent = message;
-        this.container.appendChild(successDiv);
-        setTimeout(() => successDiv.remove(), 5000);
-    }
-
-    // Add default render method
-    render() {
-        if (!this.initialized) {
-            this.initialized = true;
-        }
-    }
-
-    // Add method to get contract (used by CreateOrder)
-    async getContract() {
-        try {
-            // If we're in read-only mode, return null without throwing
-            if (!window.walletManager?.provider) {
-                this.debug('No wallet connected - running in read-only mode');
-                return null;
-            }
-
-            await window.walletInitialized;
-            const contract = await walletManager.getContract();
-            if (!contract) {
-                this.debug('Contract not initialized');
-                return null;
-            }
-            return contract;
-        } catch (error) {
-            this.debug('Error getting contract:', error);
-            return null;
-        }
-    }
-
-    // Add method to get signer (used by CreateOrder)
-    async getSigner() {
-        try {
-            if (!window.walletManager?.provider) {
-                throw new Error('Please connect your wallet first');
-            }
-            this.signer = await window.walletManager.provider.getSigner();
-            return this.signer;
-        } catch (error) {
-            console.error('[BaseComponent] Error getting signer:', error);
-            throw error;
-        }
-    }
-
-    // Add this method to BaseComponent.js
-    async getTokenDetails(tokenAddresses) {
-        try {
-            this.debug('Getting token details for:', tokenAddresses);
-            
-            // Cache verification
-            if (!this.tokenCache) {
-                this.debug('Token cache not initialized');
-                this.tokenCache = new Map();
-            }
-
-            // Ensure we have a provider
-            if (!this.provider) {
-                this.provider = window.walletManager?.provider;
-                if (!this.provider) {
-                    this.debug('No provider available - running in read-only mode');
-                    return null;
-                }
-            }
-
-            // Get signer for balance check - don't throw if not available
-            let userAddress = null;
-            try {
-                const signer = await this.getSigner().catch(() => null);
-                userAddress = signer ? await signer.getAddress() : null;
-            } catch (error) {
-                this.debug('No signer available - skipping balance check');
-            }
-
-            // Ensure tokenAddresses is an array
-            if (!Array.isArray(tokenAddresses)) {
-                tokenAddresses = [tokenAddresses];
-            }
-
-            const validAddresses = tokenAddresses.filter(addr => 
-                typeof addr === 'string' && 
-                ethers.utils.isAddress(addr)
-            );
-
-            if (validAddresses.length === 0) {
-                console.warn('[BaseComponent] No valid token addresses provided');
-                return null;
-            }
-
-            const results = await Promise.all(validAddresses.map(async (tokenAddress) => {
-                if (this.tokenCache.has(tokenAddress)) {
-                    return this.tokenCache.get(tokenAddress);
-                }
-
-                try {
-                    const tokenContract = new ethers.Contract(
-                        tokenAddress,
-                        erc20Abi,
-                        this.provider
-                    );
-
-                    const [name, symbol, decimals, balance] = await Promise.all([
-                        tokenContract.name().catch(() => 'Unknown'),
-                        tokenContract.symbol().catch(() => 'UNK'),
-                        tokenContract.decimals().catch(() => 18),
-                        userAddress ? tokenContract.balanceOf(userAddress).catch(() => '0') : '0'
-                    ]);
-
-                    const formattedBalance = ethers.utils.formatUnits(balance, decimals);
-                    
-                    const details = { 
-                        name, 
-                        symbol, 
-                        decimals, 
-                        balance,
-                        formattedBalance
-                    };
-                    
-                    this.tokenCache.set(tokenAddress, details);
-                    return details;
-                } catch (error) {
-                    console.error(`[BaseComponent] Error getting details for token ${tokenAddress}:`, error);
-                    return null;
-                }
-            }));
-
-            // Log cache updates
-            this.debug('Token cache after update:', 
-                Array.from(this.tokenCache.entries()));
-
-            return results.length === 1 ? results[0] : results;
-        } catch (error) {
-            this.debug('Error in getTokenDetails:', error);
-            return null;
-        }
-    }
-
-    // New helper method to determine if an error is retryable
-    isRetryableError(error) {
-        const retryableCodes = [-32603, -32000]; // Common RPC error codes
-        const retryableMessages = [
-            'header not found',
-            'Internal JSON-RPC error',
-            'timeout',
-            'network error',
-            'missing response',
-            'missing trie node',
-            'connection reset',
-            'connection refused'
-        ];
-
-        // Check RPC error codes
-        const rpcCode = error.error?.code || error.code;
-        if (retryableCodes.includes(rpcCode)) {
-            this.debug('Retryable RPC code detected:', rpcCode);
-            return true;
-        }
-
-        // Check error messages
-        const errorMessage = (error.message || '').toLowerCase();
-        const rpcMessage = (error.error?.message || '').toLowerCase();
-        const dataMessage = (error.data?.message || '').toLowerCase();
-
-        const hasRetryableMessage = retryableMessages.some(msg => 
-            errorMessage.includes(msg.toLowerCase()) ||
-            rpcMessage.includes(msg.toLowerCase()) ||
-            dataMessage.includes(msg.toLowerCase())
-        );
-
-        if (hasRetryableMessage) {
-            this.debug('Retryable message detected:', {
-                errorMessage,
-                rpcMessage,
-                dataMessage
-            });
-            return true;
-        }
-
-        return false;
-    }
-
-    // New helper method for detailed error logging
-    logDetailedError(prefix, error) {
-        const errorDetails = {
-            message: error.message,
-            code: error.code,
-            data: error.data,
-            reason: error.reason,
-            // RPC specific details
-            rpcError: error.error?.data || error.data,
-            rpcCode: error.error?.code || error.code,
-            rpcMessage: error.error?.message,
-            // Transaction details if available
-            transaction: error.transaction && {
-                from: error.transaction.from,
-                to: error.transaction.to,
-                data: error.transaction.data,
-                value: error.transaction.value?.toString(),
-            },
-            // Receipt if available
-            receipt: error.receipt && {
-                status: error.receipt.status,
-                gasUsed: error.receipt.gasUsed?.toString(),
-                blockNumber: error.receipt.blockNumber,
-            },
-            // Stack trace
-            stack: error.stack,
-        };
-
-        this.debug('Detailed error:', prefix, errorDetails);
-        return errorDetails;
-    }
-
-    // Modified retry call with better logging
-    async retryCall(fn, maxRetries = 3, delay = 1000) {
-        for (let i = 0; i < maxRetries; i++) {
-            try {
-                this.debug(`Attempt ${i + 1}/${maxRetries}`);
-                return await fn();
-            } catch (error) {
-                const errorDetails = this.logDetailedError(
-                    `Attempt ${i + 1} failed:`,
-                    error
-                );
-
-                const isRetryable = this.isRetryableError(error);
-                this.debug('Error is retryable:', isRetryable, {
-                    errorCode: errorDetails.code,
-                    rpcCode: errorDetails.rpcCode,
-                    message: errorDetails.message
-                });
-
-                if (i === maxRetries - 1 || !isRetryable) {
-                    this.debug('Max retries reached or non-retryable error');
-                    throw error;
-                }
-                
-                const waitTime = delay * Math.pow(2, i); // Exponential backoff
-                this.debug(`Retrying in ${waitTime}ms...`);
-                await new Promise(resolve => setTimeout(resolve, waitTime));
-            }
-        }
-    }
-}
diff --git a/otc/js/components/Cleanup.js b/otc/js/components/Cleanup.js
deleted file mode 100644
index 1e68ef5..0000000
--- a/otc/js/components/Cleanup.js
+++ /dev/null
@@ -1,338 +0,0 @@
-import { ethers } from 'ethers';
-import { BaseComponent } from './BaseComponent.js';
-import { isDebugEnabled } from '../config.js';
-
-export class Cleanup extends BaseComponent {
-    constructor(containerId) {
-        super('cleanup-container');
-        this.webSocket = window.webSocket;
-        
-        this.debug = (message, ...args) => {
-            if (isDebugEnabled('CLEANUP')) {
-                console.log('[Cleanup]', message, ...args);
-            }
-        };
-    }
-
-    async initialize(readOnlyMode = true) {
-        try {
-            this.debug('Initializing cleanup component...');
-            
-            // Wait for both WebSocket and Contract to be ready
-            if (!this.webSocket?.isInitialized || !this.webSocket?.contract) {
-                this.debug('Waiting for WebSocket service and contract to initialize...');
-                let attempts = 0;
-                while (attempts < 10) {
-                    if (window.webSocket?.isInitialized && window.webSocket?.contract) {
-                        this.webSocket = window.webSocket;
-                        this.debug('WebSocket service and contract found');
-                        break;
-                    }
-                    this.debug(`Attempt ${attempts + 1}: Waiting for WebSocket...`);
-                    await new Promise(resolve => setTimeout(resolve, 500));
-                    attempts++;
-                }
-            }
-
-            // Verify both WebSocket and Contract are available
-            if (!this.webSocket?.isInitialized || !this.webSocket?.contract) {
-                throw new Error('WebSocket service or contract not properly initialized');
-            }
-
-            // Setup WebSocket event listeners
-            this.setupWebSocket();
-
-            this.container.innerHTML = '';
-            
-            if (readOnlyMode) {
-                this.debug('Read-only mode, showing connect prompt');
-                this.container.innerHTML = `
-                    <div class="tab-content-wrapper">
-                        <h2>Cleanup Expired Orders</h2>
-                        <p class="connect-prompt">Connect wallet to view cleanup opportunities</p>
-                    </div>`;
-                return;
-            }
-
-            this.debug('Setting up UI components');
-            const wrapper = this.createElement('div', 'tab-content-wrapper');
-            wrapper.innerHTML = `
-                <div class="cleanup-section">
-                    <h2>Cleanup Expired Orders</h2>
-                    <div class="cleanup-info">
-                        <p>Earn fees by cleaning up expired orders</p>
-                        <div class="cleanup-stats">
-                            <div class="cleanup-category">
-                                <h3>Active Orders</h3>
-                                <div>Count: <span id="active-orders-count">Loading...</span></div>
-                                <div>Fees: <span id="active-orders-fees">Loading...</span></div>
-                            </div>
-                            <div class="cleanup-category">
-                                <h3>Cancelled Orders</h3>
-                                <div>Count: <span id="cancelled-orders-count">Loading...</span></div>
-                                <div>Fees: <span id="cancelled-orders-fees">Loading...</span></div>
-                            </div>
-                            <div class="cleanup-total">
-                                <h3>Total</h3>
-                                <div>Orders Ready: <span id="cleanup-ready">Loading...</span></div>
-                                <div>Total Reward: <span id="cleanup-reward">Loading...</span></div>
-                            </div>
-                        </div>
-                    </div>
-                    <button id="cleanup-button" class="action-button" disabled>
-                        Clean Orders
-                    </button>
-                </div>
-            `;
-            
-            this.container.appendChild(wrapper);
-
-            this.cleanupButton = document.getElementById('cleanup-button');
-            this.cleanupButton.addEventListener('click', () => this.performCleanup());
-
-            this.debug('Starting cleanup opportunities check');
-            await this.checkCleanupOpportunities();
-            
-            this.intervalId = setInterval(() => this.checkCleanupOpportunities(), 5 * 60 * 1000);
-            this.debug('Initialization complete');
-        } catch (error) {
-            this.debug('Initialization failed:', error);
-            this.showError('Failed to initialize cleanup component');
-            this.updateUIForError();
-        }
-    }
-
-    cleanup() {
-        if (this.intervalId) {
-            this.debug('Cleaning up interval');
-            clearInterval(this.intervalId);
-        }
-    }
-
-    async checkCleanupOpportunities() {
-        try {
-            // Verify WebSocket and contract before proceeding
-            if (!this.webSocket?.contract) {
-                throw new Error('Contract not available for cleanup check');
-            }
-
-            const orders = this.webSocket.getOrders();
-            if (!Array.isArray(orders)) {
-                throw new Error('Invalid orders data received from WebSocket');
-            }
-
-            const eligibleOrders = {
-                active: [],
-                cancelled: []
-            };
-            let activeFees = 0;
-            let cancelledFees = 0;
-            
-            for (const order of orders) {
-                const { isEligible, order: orderDetails } = await this.webSocket.checkCleanupEligibility(order.id);
-                if (isEligible) {
-                    if (orderDetails.status === 'Active') {
-                        eligibleOrders.active.push(orderDetails);
-                        activeFees += Number(orderDetails.orderCreationFee || 0);
-                    } else if (orderDetails.status === 'Canceled') {
-                        eligibleOrders.cancelled.push(orderDetails);
-                        cancelledFees += Number(orderDetails.orderCreationFee || 0);
-                    }
-                }
-            }
-            
-            const totalEligible = eligibleOrders.active.length + eligibleOrders.cancelled.length;
-            const totalFees = activeFees + cancelledFees;
-            
-            // Update UI elements
-            const elements = {
-                activeCount: document.getElementById('active-orders-count'),
-                activeFees: document.getElementById('active-orders-fees'),
-                cancelledCount: document.getElementById('cancelled-orders-count'),
-                cancelledFees: document.getElementById('cancelled-orders-fees'),
-                totalReward: document.getElementById('cleanup-reward'),
-                totalReady: document.getElementById('cleanup-ready'),
-                cleanupButton: document.getElementById('cleanup-button')
-            };
-            
-            if (elements.activeCount) {
-                elements.activeCount.textContent = eligibleOrders.active.length.toString();
-            }
-            if (elements.activeFees) {
-                elements.activeFees.textContent = `${this.formatEth(activeFees)} ETH`;
-            }
-            if (elements.cancelledCount) {
-                elements.cancelledCount.textContent = eligibleOrders.cancelled.length.toString();
-            }
-            if (elements.cancelledFees) {
-                elements.cancelledFees.textContent = `${this.formatEth(cancelledFees)} ETH`;
-            }
-            if (elements.totalReward) {
-                elements.totalReward.textContent = `${this.formatEth(totalFees)} ETH`;
-            }
-            if (elements.totalReady) {
-                elements.totalReady.textContent = totalEligible.toString();
-            }
-            if (elements.cleanupButton) {
-                elements.cleanupButton.disabled = totalEligible === 0;
-                elements.cleanupButton.textContent = `Clean ${totalEligible} Order${totalEligible !== 1 ? 's' : ''}`;
-            }
-
-            this.debug('Cleanup stats:', {
-                active: {
-                    count: eligibleOrders.active.length,
-                    fees: this.formatEth(activeFees)
-                },
-                cancelled: {
-                    count: eligibleOrders.cancelled.length,
-                    fees: this.formatEth(cancelledFees)
-                },
-                total: {
-                    count: totalEligible,
-                    fees: this.formatEth(totalFees)
-                }
-            });
-
-        } catch (error) {
-            this.debug('Error checking cleanup opportunities:', error);
-            this.showError('Failed to check cleanup opportunities');
-            this.updateUIForError();
-        }
-    }
-
-    updateUIForError() {
-        const errorText = 'Error';
-        ['active-orders-count', 'active-orders-fees', 
-         'cancelled-orders-count', 'cancelled-orders-fees',
-         'cleanup-reward', 'cleanup-ready'].forEach(id => {
-            const element = document.getElementById(id);
-            if (element) element.textContent = errorText;
-        });
-    }
-
-    setupWebSocket() {
-        if (!this.webSocket) {
-            this.debug('WebSocket not available for setup');
-            return;
-        }
-
-        // Subscribe to all relevant events
-        this.webSocket.subscribe('OrderCleaned', () => {
-            this.debug('Order cleaned event received');
-            this.checkCleanupOpportunities();
-        });
-
-        this.webSocket.subscribe('OrderCanceled', () => {
-            this.debug('Order canceled event received');
-            this.checkCleanupOpportunities();
-        });
-
-        this.webSocket.subscribe('OrderFilled', () => {
-            this.debug('Order filled event received');
-            this.checkCleanupOpportunities();
-        });
-
-        this.webSocket.subscribe('orderSyncComplete', () => {
-            this.debug('Order sync complete event received');
-            this.checkCleanupOpportunities();
-        });
-    }
-
-    async performCleanup() {
-        try {
-            // Use WebSocket's contract instance instead of getting a new one
-            const contract = this.webSocket?.contract;
-            if (!contract) {
-                throw new Error('Contract not initialized');
-            }
-
-            this.cleanupButton.disabled = true;
-            this.cleanupButton.textContent = 'Cleaning...';
-
-            // Get current network conditions
-            const provider = contract.provider;
-            const feeData = await provider.getFeeData();
-            
-            // Get gas estimate
-            const gasEstimate = await contract.estimateGas.cleanupExpiredOrders()
-                .catch(error => {
-                    console.log('[Cleanup] Gas estimation failed:', error);
-                    return ethers.BigNumber.from('300000'); // Default gas limit
-                });
-
-            // Add 20% buffer to gas estimate
-            const gasLimit = gasEstimate.mul(120).div(100);
-
-            // Use legacy transaction type
-            const txOptions = {
-                gasLimit,
-                gasPrice: feeData.gasPrice,
-                type: 0  // Force legacy transaction
-            };
-
-            console.log('[Cleanup] Sending transaction with options:', txOptions);
-            const tx = await contract.cleanupExpiredOrders(txOptions);
-            console.log('[Cleanup] Transaction sent:', tx.hash);
-
-            const receipt = await tx.wait();
-            console.log('[Cleanup] Transaction confirmed:', receipt);
-            console.log('[Cleanup] Events:', receipt.events);
-
-            if (receipt.status === 0) {
-                throw new Error('Transaction failed during execution');
-            }
-
-            // Parse cleanup events from receipt
-            const cleanedOrderIds = receipt.events
-                ?.filter(event => {
-                    console.log('[Cleanup] Processing event:', event);
-                    return event.event === 'OrderCleanedUp';
-                })
-                ?.map(event => {
-                    console.log('[Cleanup] Cleaned order:', event.args);
-                    return event.args.orderId.toString();
-                });
-                
-            console.log('[Cleanup] Cleaned order IDs:', cleanedOrderIds);
-                
-            if (cleanedOrderIds?.length) {
-                this.debug('Orders cleaned:', cleanedOrderIds);
-                // Remove cleaned orders from WebSocket cache
-                this.webSocket.removeOrders(cleanedOrderIds);
-                // Force a fresh sync
-                await this.webSocket.syncAllOrders(contract);
-            }
-
-            this.showSuccess('Cleanup successful! Check your wallet for rewards.');
-            await this.checkCleanupOpportunities();
-
-        } catch (error) {
-            console.error('[Cleanup] Error details:', {
-                message: error.message,
-                code: error.code,
-                error: error.error,
-                reason: error.reason,
-                transaction: error.transaction
-            });
-            this.showError(`Cleanup failed: ${error.message}`);
-        } finally {
-            this.cleanupButton.textContent = 'Clean Orders';
-            this.cleanupButton.disabled = false;
-        }
-    }
-
-    showSuccess(message) {
-        this.debug('Success:', message);
-        // Implement your success notification
-    }
-
-    showError(message) {
-        this.debug('Error:', message);
-        // Implement your error notification
-    }
-
-    // Add helper method to format ETH values
-    formatEth(wei) {
-        return ethers.utils.formatEther(wei.toString());
-    }
-} 
\ No newline at end of file
diff --git a/otc/js/components/CreateOrder.js b/otc/js/components/CreateOrder.js
deleted file mode 100644
index 79717ac..0000000
--- a/otc/js/components/CreateOrder.js
+++ /dev/null
@@ -1,480 +0,0 @@
-import { BaseComponent } from './BaseComponent.js';
-import { ethers } from 'ethers';
-import { getNetworkConfig, isDebugEnabled } from '../config.js';
-import { erc20Abi } from '../abi/erc20.js';
-
-export class CreateOrder extends BaseComponent {
-    constructor() {
-        super('create-order');
-        this.contract = null;
-        this.provider = null;
-        this.initialized = false;
-        this.tokenCache = new Map();
-        this.boundCreateOrderHandler = this.handleCreateOrder.bind(this);
-        this.isSubmitting = false;
-        
-        // Initialize debug logger
-        this.debug = (message, ...args) => {
-            if (isDebugEnabled('CREATE_ORDER')) {
-                console.log('[CreateOrder]', message, ...args);
-            }
-        };
-    }
-
-    async initializeContract() {
-        try {
-            this.debug('Initializing contract...');
-            const networkConfig = getNetworkConfig();
-            
-            this.debug('Network config:', {
-                address: networkConfig.contractAddress,
-                abiLength: networkConfig.contractABI?.length
-            });
-
-            if (!networkConfig.contractABI) {
-                throw new Error('Contract ABI is undefined');
-            }
-            
-            // Get provider and signer
-            this.provider = new ethers.providers.Web3Provider(window.ethereum);
-            const signer = this.provider.getSigner();
-            
-            // Initialize contract with explicit ABI check
-            this.contract = new ethers.Contract(
-                networkConfig.contractAddress,
-                networkConfig.contractABI,
-                signer
-            );
-            
-            this.debug('Contract initialized successfully');
-            return this.contract;
-        } catch (error) {
-            console.error('[CreateOrder] Contract initialization error:', error);
-            throw error;
-        }
-    }
-
-    async initialize(readOnlyMode = true) {
-        if (this.initialized) return;
-        try {
-            this.debug('Starting initialization...');
-            
-            if (readOnlyMode) {
-                this.setReadOnlyMode();
-                return;
-            }
-
-            // Enable form when wallet is connected
-            this.setConnectedMode();
-            
-            // Initialize contract and load fee
-            await this.initializeContract();
-            await this.loadOrderCreationFee();
-            
-            // Setup all event listeners
-            this.setupTokenInputListeners();
-            this.setupCreateOrderListener();
-            
-            this.debug('Initialization complete');
-            this.initialized = true;
-        } catch (error) {
-            console.error('[CreateOrder] Error in initialization:', error);
-            this.showError('Failed to initialize. Please refresh the page.');
-        }
-    }
-
-    async loadOrderCreationFee() {
-        try {
-            this.debug('Loading order creation fee...');
-            if (!this.contract) {
-                throw new Error('Contract not initialized');
-            }
-            const fee = await this.contract.orderCreationFee();
-            const averageGas = await this.contract.averageGasUsed();
-            const feeInEth = ethers.utils.formatEther(fee);
-            
-            // Format the fee to be more readable
-            const formattedFee = parseFloat(feeInEth).toFixed(6); // Show 6 decimal places
-            const formattedGas = averageGas.toNumber().toLocaleString(); // Add thousands separator
-            
-            const orderCreationFee = document.getElementById('orderCreationFee');
-            if (orderCreationFee) {
-                orderCreationFee.innerHTML = `
-                    <div class="fee-details">
-                        <div class="fee-amount">${formattedFee} POL</div>
-                        <div class="fee-gas">Average Gas: ${formattedGas}</div>
-                    </div>`;
-                orderCreationFee.classList.remove('placeholder-text');
-            }
-            this.debug('Fee loaded:', feeInEth, 'Average Gas:', averageGas);
-        } catch (error) {
-            console.error('[CreateOrder] Error loading fee:', error);
-            const orderCreationFee = document.getElementById('orderCreationFee');
-            if (orderCreationFee) {
-                orderCreationFee.textContent = 'Error loading fee';
-            }
-        }
-    }
-
-    setReadOnlyMode() {
-        const createOrderBtn = document.getElementById('createOrderBtn');
-        const orderCreationFee = document.getElementById('orderCreationFee');
-        
-        createOrderBtn.disabled = true;
-        createOrderBtn.textContent = 'Connect Wallet to Create Order';
-        orderCreationFee.textContent = 'Connect wallet to view fee';
-        orderCreationFee.classList.add('placeholder-text');
-        
-        // Disable input fields
-        ['partner', 'sellToken', 'sellAmount', 'buyToken', 'buyAmount'].forEach(id => {
-            const element = document.getElementById(id);
-            if (element) element.disabled = true;
-        });
-    }
-
-    setConnectedMode() {
-        const createOrderBtn = document.getElementById('createOrderBtn');
-        const orderCreationFee = document.getElementById('orderCreationFee');
-        
-        createOrderBtn.disabled = false;
-        createOrderBtn.textContent = 'Create Order';
-        orderCreationFee.classList.remove('placeholder-text');
-        
-        // Enable input fields
-        ['partner', 'sellToken', 'sellAmount', 'buyToken', 'buyAmount'].forEach(id => {
-            const element = document.getElementById(id);
-            if (element) element.disabled = false;
-        });
-    }
-
-    async updateTokenBalance(tokenAddress, elementId) {
-        try {
-            if (!tokenAddress || !ethers.utils.isAddress(tokenAddress)) {
-                document.getElementById(elementId).textContent = '';
-                return;
-            }
-
-            const tokenDetails = await this.getTokenDetails(tokenAddress);
-            if (tokenDetails && tokenDetails.symbol) {
-                const balanceElement = document.getElementById(elementId);
-                const formattedBalance = parseFloat(tokenDetails.formattedBalance).toFixed(4);
-                balanceElement.textContent = `Balance: ${formattedBalance} ${tokenDetails.symbol}`;
-            }
-        } catch (error) {
-            console.error(`Error updating token balance:`, error);
-            document.getElementById(elementId).textContent = 'Error loading balance';
-        }
-    }
-
-    setupTokenInputListeners() {
-        const sellTokenInput = document.getElementById('sellToken');
-        const buyTokenInput = document.getElementById('buyToken');
-
-        const updateBalance = async (input, balanceId) => {
-            const tokenAddress = input.value.trim();
-            await this.updateTokenBalance(tokenAddress, balanceId);
-        };
-
-        sellTokenInput.addEventListener('change', () => updateBalance(sellTokenInput, 'sellTokenBalance'));
-        buyTokenInput.addEventListener('change', () => updateBalance(buyTokenInput, 'buyTokenBalance'));
-    }
-
-    setupCreateOrderListener() {
-        const createOrderBtn = document.getElementById('createOrderBtn');
-        // Remove ALL existing listeners using clone technique
-        const newButton = createOrderBtn.cloneNode(true);
-        createOrderBtn.parentNode.replaceChild(newButton, createOrderBtn);
-        // Add single new listener
-        newButton.addEventListener('click', this.boundCreateOrderHandler);
-    }
-
-    async handleCreateOrder(event) {
-        event.preventDefault();
-        
-        // Prevent double submission
-        if (this.isSubmitting) {
-            this.debug('Order submission already in progress');
-            return;
-        }
-
-        const createOrderBtn = document.getElementById('createOrderBtn');
-        try {
-            this.isSubmitting = true;
-            createOrderBtn.disabled = true;
-            createOrderBtn.textContent = 'Processing...';
-            
-            if (!this.provider || !this.contract) {
-                throw new Error('Contract or provider not initialized');
-            }
-
-            // Get form values
-            const partner = document.getElementById('partner').value.trim();
-            const sellToken = document.getElementById('sellToken').value.trim();
-            const sellAmount = document.getElementById('sellAmount').value.trim();
-            const buyToken = document.getElementById('buyToken').value.trim();
-            const buyAmount = document.getElementById('buyAmount').value.trim();
-
-            // Validation
-            if (!ethers.utils.isAddress(sellToken)) {
-                throw new Error('Invalid sell token address');
-            }
-            if (!ethers.utils.isAddress(buyToken)) {
-                throw new Error('Invalid buy token address');
-            }
-            if (!sellAmount || isNaN(sellAmount)) {
-                throw new Error('Invalid sell amount');
-            }
-            if (!buyAmount || isNaN(buyAmount)) {
-                throw new Error('Invalid buy amount');
-            }
-            if (partner && !ethers.utils.isAddress(partner)) {
-                throw new Error('Invalid partner address');
-            }
-
-            // Get token contracts with full ERC20 ABI for better interaction
-            const sellTokenContract = new ethers.Contract(
-                sellToken,
-                erc20Abi, // Use full ERC20 ABI
-                this.provider
-            );
-            const buyTokenContract = new ethers.Contract(
-                buyToken,
-                erc20Abi, // Use full ERC20 ABI
-                this.provider
-            );
-            
-            // Get decimals in parallel
-            const [sellDecimals, buyDecimals] = await Promise.all([
-                sellTokenContract.decimals(),
-                buyTokenContract.decimals()
-            ]);
-
-            // Convert amounts to Wei
-            const sellAmountWei = ethers.utils.parseUnits(sellAmount, sellDecimals);
-            const buyAmountWei = ethers.utils.parseUnits(buyAmount, buyDecimals);
-
-            // Check balance first
-            const signer = await this.getSigner();
-            const signerAddress = await signer.getAddress();
-            const balance = await sellTokenContract.balanceOf(signerAddress);
-            
-            this.debug('Balance check:', {
-                balance: balance.toString(),
-                required: sellAmountWei.toString(),
-                decimals: sellDecimals
-            });
-
-            if (balance.lt(sellAmountWei)) {
-                throw new Error(
-                    `Insufficient token balance. Have ${ethers.utils.formatUnits(balance, sellDecimals)}, ` +
-                    `need ${ethers.utils.formatUnits(sellAmountWei, sellDecimals)}`
-                );
-            }
-
-            // Check and request token approval if needed
-            const allowance = await sellTokenContract.allowance(signerAddress, this.contract.address);
-            this.debug('Current allowance:', allowance.toString());
-
-            if (allowance.lt(sellAmountWei)) {
-                this.showSuccess('Requesting token approval...');
-                
-                try {
-                    // Skip gas estimation and use standard parameters
-                    const approveTx = await sellTokenContract.connect(signer).approve(
-                        this.contract.address,
-                        sellAmountWei,
-                        {
-                            gasLimit: 70000,  // Standard gas limit for ERC20 approvals
-                            gasPrice: await this.provider.getGasPrice()
-                        }
-                    );
-                    
-                    this.debug('Approval transaction sent:', approveTx.hash);
-                    await approveTx.wait();
-                    this.showSuccess('Token approval granted');
-                } catch (error) {
-                    // Check if the error is due to user rejection
-                    if (error.code === 4001) { // MetaMask user rejected
-                        this.showError('Token approval was rejected');
-                        throw new Error('Token approval rejected by user');
-                    }
-                    
-                    // If it's a revert with specific error code
-                    if (error?.error?.data?.data === '0xe602df050000000000000000000000000000000000000000000000000000000000000000') {
-                        this.debug('Known contract error during approval:', error);
-                        throw new Error('Token approval failed - contract rejected the transaction');
-                    }
-                    
-                    this.debug('Approval failed:', error);
-                    throw new Error('Token approval failed. Please try again.');
-                }
-            }
-
-            // Get the order creation fee
-            const fee = await this.contract.orderCreationFee();
-
-            // Estimate gas for createOrder with fallback
-            let createOrderGasLimit;
-            try {
-                const createOrderGasEstimate = await this.contract.estimateGas.createOrder(
-                    partner || ethers.constants.AddressZero,
-                    sellToken,
-                    sellAmountWei,
-                    buyToken,
-                    buyAmountWei,
-                    { value: fee }
-                );
-                this.debug('Create order gas estimate:', createOrderGasEstimate.toString());
-                createOrderGasLimit = Math.floor(createOrderGasEstimate.toNumber() * 1.2); // 20% buffer
-            } catch (error) {
-                this.debug('Gas estimation failed for create order, using default:', error);
-                createOrderGasLimit = 300000; // Default gas limit for order creation
-            }
-
-            this.debug('Sending create order transaction with params:', {
-                taker: partner || ethers.constants.AddressZero,
-                sellToken,
-                sellAmount: sellAmountWei.toString(),
-                buyToken,
-                buyAmount: buyAmountWei.toString(),
-                fee: fee.toString(),
-                gasLimit: createOrderGasLimit,
-                gasPrice: (await this.provider.getGasPrice()).toString()
-            });
-
-            const tx = await this.contract.createOrder(
-                partner || ethers.constants.AddressZero,
-                sellToken,
-                sellAmountWei,
-                buyToken,
-                buyAmountWei,
-                {
-                    value: fee,
-                    gasLimit: createOrderGasLimit,
-                    gasPrice: await this.provider.getGasPrice()
-                }
-            );
-
-            this.debug('Transaction sent:', tx.hash);
-            this.showSuccess('Order creation transaction submitted');
-
-            const receipt = await tx.wait();
-            this.debug('Transaction confirmed:', receipt);
-            
-            // Refresh the fee after order creation
-            await this.loadOrderCreationFee();
-
-            // Look for OrderCreated event
-            const orderCreatedEvent = receipt.events?.find(e => e.event === 'OrderCreated');
-            if (orderCreatedEvent) {
-                this.debug('OrderCreated event found:', orderCreatedEvent);
-            } else {
-                console.warn('[CreateOrder] No OrderCreated event found in receipt');
-            }
-
-            this.showSuccess('Order created successfully!');
-            this.resetForm();
-            
-        } catch (error) {
-            this.debug('Create order error details:', {
-                message: error.message,
-                code: error.code,
-                data: error?.error?.data,
-                reason: error?.reason,
-                stack: error.stack,
-                transactionHash: error?.transaction?.hash
-            });
-            
-            // Check for specific revert code 0xe602df05
-            if (error?.error?.data?.data === '0xe602df050000000000000000000000000000000000000000000000000000000000000000') {
-                try {
-                    // Try to decode the error using contract interface
-                    const decodedError = this.contract.interface.parseError(error.error.data.data);
-                    this.debug('Decoded contract error:', decodedError);
-                    
-                    // If transaction actually succeeded despite the error
-                    if (error?.transaction?.hash) {
-                        const receipt = await this.provider.getTransactionReceipt(error.transaction.hash);
-                        if (receipt && receipt.status === 1) {
-                            this.showSuccess('Order created successfully despite RPC error');
-                            this.resetForm();
-                            return;
-                        }
-                    }
-                    
-                    // If we get here, it's a real error
-                    this.showError(`Contract error: ${decodedError.name}`);
-                } catch (decodeError) {
-                    this.debug('Failed to decode contract error:', decodeError);
-                    this.showError('Failed to create order: Contract reverted');
-                }
-                return;
-            }
-
-            let errorMessage = 'Failed to create order: ';
-            
-            // Try to decode the error
-            if (error?.error?.data) {
-                try {
-                    const decodedError = this.contract.interface.parseError(error.error.data);
-                    errorMessage += `${decodedError.name}: ${decodedError.args}`;
-                    this.debug('Decoded error:', decodedError);
-                } catch (e) {
-                    // If we can't decode the error, fall back to basic messages
-                    errorMessage += this.getReadableError(error);
-                }
-            } else {
-                errorMessage += this.getReadableError(error);
-            }
-            
-            this.showError(errorMessage);
-        } finally {
-            this.isSubmitting = false;
-            createOrderBtn.disabled = false;
-            createOrderBtn.textContent = 'Create Order';
-        }
-    }
-
-    async checkAllowance(tokenAddress, owner, amount) {
-        try {
-            const tokenContract = new ethers.Contract(
-                tokenAddress,
-                ['function allowance(address owner, address spender) view returns (uint256)'],
-                this.provider
-            );
-            const allowance = await tokenContract.allowance(owner, this.contract.address);
-            return allowance.gte(amount);
-        } catch (error) {
-            console.error('[CreateOrder] Error checking allowance:', error);
-            return false;
-        }
-    }
-
-    getReadableError(error) {
-        // Add more specific error cases
-        switch (error.code) {
-            case 'ACTION_REJECTED':
-                return 'Transaction was rejected by user';
-            case 'INSUFFICIENT_FUNDS':
-                return 'Insufficient funds for transaction';
-            case -32603:
-                return 'Network error. Please check your connection';
-            case 'UNPREDICTABLE_GAS_LIMIT':
-                return 'Error estimating gas. The transaction may fail';
-            default:
-                return error.reason || error.message || 'Error creating order';
-        }
-    }
-
-    resetForm() {
-        ['sellAmount', 'buyAmount'].forEach(id => {
-            const element = document.getElementById(id);
-            if (element) element.value = '';
-        });
-        ['sellTokenBalance', 'buyTokenBalance'].forEach(id => {
-            const element = document.getElementById(id);
-            if (element) element.textContent = '';
-        });
-    }
-}
-
diff --git a/otc/js/components/MyOrders.js b/otc/js/components/MyOrders.js
deleted file mode 100644
index b31e84e..0000000
--- a/otc/js/components/MyOrders.js
+++ /dev/null
@@ -1,404 +0,0 @@
-import { ViewOrders } from './ViewOrders.js';
-import { ethers } from 'ethers';
-import { isDebugEnabled } from '../config.js';
-
-export class MyOrders extends ViewOrders {
-    constructor() {
-        super('my-orders');
-        
-        // Initialize sort config
-        this.sortConfig = {
-            column: 'id',
-            direction: 'asc'
-        };
-        
-        // Initialize debug logger
-        this.debug = (message, ...args) => {
-            if (isDebugEnabled('MY_ORDERS')) {
-                console.log('[MyOrders]', message, ...args);
-            }
-        };
-    }
-
-    async initialize(readOnlyMode = true) {
-        try {
-            this.debug('Initializing MyOrders component');
-            
-            if (readOnlyMode || !window.walletManager?.provider) {
-                this.container.innerHTML = `
-                    <div class="tab-content-wrapper">
-                        <h2>My Orders</h2>
-                        <p class="connect-prompt">Connect wallet to view your orders</p>
-                    </div>`;
-                return;
-            }
-
-            // Get current account
-            let userAddress;
-            try {
-                userAddress = await window.walletManager.getAccount();
-            } catch (error) {
-                this.debug('Error getting account:', error);
-                userAddress = null;
-            }
-
-            if (!userAddress) {
-                this.debug('No account connected');
-                this.container.innerHTML = `
-                    <div class="tab-content-wrapper">
-                        <h2>My Orders</h2>
-                        <p class="connect-prompt">Connect wallet to view your orders</p>
-                    </div>`;
-                return;
-            }
-
-            // Cleanup previous state
-            this.cleanup();
-            this.container.innerHTML = '';
-            
-            await this.setupTable();
-
-            // Setup WebSocket handlers after table setup
-            this.setupWebSocket();
-
-            // Get initial orders from cache and filter for maker
-            const cachedOrders = window.webSocket?.getOrders() || [];
-            const filteredOrders = cachedOrders.filter(order => 
-                order?.maker && userAddress && 
-                order.maker.toLowerCase() === userAddress.toLowerCase()
-            );
-
-            // Clear existing orders and add filtered ones
-            this.orders.clear();
-            if (filteredOrders.length > 0) {
-                this.debug('Loading orders from cache:', filteredOrders);
-                filteredOrders.forEach(order => {
-                    this.orders.set(order.id, order);
-                });
-            }
-
-            await this.refreshOrdersView();
-
-        } catch (error) {
-            console.error('[MyOrders] Initialization error:', error);
-            this.container.innerHTML = `
-                <div class="tab-content-wrapper">
-                    <h2>My Orders</h2>
-                    <p class="error-message">Failed to load orders. Please try again later.</p>
-                </div>`;
-        }
-    }
-
-    setupWebSocket() {
-        // First call parent's setupWebSocket if it exists
-        if (super.setupWebSocket) {
-            super.setupWebSocket();
-        }
-
-        // Add OrderCanceled event handler
-        this.eventSubscriptions.add({
-            event: 'OrderCanceled',
-            callback: async (orderData) => {
-                this.debug('Order canceled event received:', orderData);
-                
-                // Update the order in our local state
-                if (this.orders.has(orderData.id)) {
-                    const order = this.orders.get(orderData.id);
-                    order.status = 'Canceled';
-                    this.orders.set(orderData.id, order);
-                    
-                    // Update UI elements
-                    const statusCell = this.container.querySelector(`tr[data-order-id="${orderData.id}"] .order-status`);
-                    const actionCell = this.container.querySelector(`tr[data-order-id="${orderData.id}"] .action-column`);
-                    
-                    if (statusCell) {
-                        statusCell.textContent = 'Canceled';
-                        statusCell.className = 'order-status canceled';
-                    }
-                    if (actionCell) {
-                        actionCell.innerHTML = '<span class="order-status">Canceled</span>';
-                    }
-                }
-            }
-        });
-    }
-
-    async cancelOrder(orderId) {
-        const button = this.container.querySelector(`button[data-order-id="${orderId}"]`);
-        
-        try {
-            if (button) {
-                button.disabled = true;
-                button.textContent = 'Canceling...';
-            }
-
-            this.debug('Starting cancel order process for orderId:', orderId);
-            const contract = await this.getContract();
-            
-            // Estimate gas for cancelOrder with fallback
-            let cancelGasLimit;
-            try {
-                const cancelGasEstimate = await contract.estimateGas.cancelOrder(orderId);
-                cancelGasLimit = Math.floor(cancelGasEstimate.toNumber() * 1.2); // 20% buffer
-            } catch (error) {
-                this.debug('Gas estimation failed for cancel order, using default:', error);
-                cancelGasLimit = 100000; // Default gas limit for cancel orders
-            }
-
-            const tx = await contract.cancelOrder(orderId, {
-                gasLimit: cancelGasLimit,
-                gasPrice: await this.provider.getGasPrice()
-            });
-            
-            this.debug('Cancel transaction sent:', tx.hash);
-            this.showSuccess('Cancel transaction submitted');
-            
-            await tx.wait();
-            this.debug('Transaction confirmed');
-
-        } catch (error) {
-            this.debug('Cancel order error:', error);
-            let errorMessage = 'Failed to cancel order: ';
-            
-            if (error?.error?.data) {
-                try {
-                    const decodedError = this.contract.interface.parseError(error.error.data);
-                    errorMessage += `${decodedError.name}: ${decodedError.args}`;
-                } catch (e) {
-                    if (error.code === -32603) {
-                        errorMessage += 'Transaction would fail. Please try again.';
-                    } else {
-                        errorMessage += error.message;
-                    }
-                }
-            }
-            
-            this.showError(errorMessage);
-            
-            // Reset button state on error
-            if (button) {
-                button.disabled = false;
-                button.textContent = 'Cancel';
-            }
-        }
-    }
-
-    async createOrderRow(order, tokenDetailsMap) {
-        const tr = await super.createOrderRow(order, tokenDetailsMap);
-        const actionCell = tr.querySelector('.action-column');
-        const statusCell = tr.querySelector('.order-status');
-        const expiresCell = tr.querySelector('td:nth-child(6)'); // Expires column
-        
-        if (actionCell && statusCell) {
-            try {
-                const currentTime = Math.floor(Date.now() / 1000);
-                const orderTime = Number(order.timestamp);
-                const contract = await this.getContract();
-                
-                // Get expiry times directly from contract
-                const orderExpiry = await contract.ORDER_EXPIRY();
-                const gracePeriod = await contract.GRACE_PERIOD();
-                
-                const expiryTime = orderTime + orderExpiry.toNumber();
-                const timeDiff = expiryTime - currentTime;
-                
-                // Format time difference for expires column
-                const formatTimeDiff = (diff) => {
-                    const absHours = Math.floor(Math.abs(diff) / 3600);
-                    const absMinutes = Math.floor((Math.abs(diff) % 3600) / 60);
-                    const sign = diff < 0 ? '-' : '';
-                    return `${sign}${absHours}h ${absMinutes}m`;
-                };
-
-                // Update expires column with the time difference
-                if (expiresCell) {
-                    expiresCell.textContent = formatTimeDiff(timeDiff);
-                }
-
-                const isGracePeriodExpired = currentTime > orderTime + orderExpiry.toNumber() + gracePeriod.toNumber();
-                
-                // Status column only shows contract states
-                if (order.status === 'Canceled') {
-                    statusCell.textContent = 'Canceled';
-                    statusCell.className = 'order-status canceled';
-                } else if (order.status === 'Filled') {
-                    statusCell.textContent = 'Filled';
-                    statusCell.className = 'order-status filled';
-                } else {
-                    statusCell.textContent = 'Active';
-                    statusCell.className = 'order-status active';
-                }
-
-                // Keep existing action column logic
-                if (order.status === 'Canceled') {
-                    actionCell.innerHTML = '<span class="order-status">Canceled</span>';
-                } else if (order.status === 'Filled') {
-                    actionCell.innerHTML = '<span class="order-status">Filled</span>';
-                } else if (isGracePeriodExpired) {
-                    actionCell.innerHTML = '<span class="order-status">Await Cleanup</span>';
-                } else {
-                    actionCell.innerHTML = `
-                        <button class="cancel-button" data-order-id="${order.id}">Cancel</button>
-                    `;
-                    const cancelButton = actionCell.querySelector('.cancel-button');
-                    if (cancelButton) {
-                        cancelButton.addEventListener('click', () => this.cancelOrder(order.id));
-                    }
-                }
-            } catch (error) {
-                console.error('[MyOrders] Error in createOrderRow:', error);
-                actionCell.innerHTML = '<span class="order-status error">Error</span>';
-            }
-        }
-
-        return tr;
-    }
-
-    async refreshOrdersView() {
-        try {
-            this.debug('Initializing MyOrders component');
-            
-            // Get contract instance first
-            this.contract = await this.getContract();
-            if (!this.contract) {
-                throw new Error('Contract not initialized');
-            }
-
-            // Clear existing orders from table
-            const tbody = this.container.querySelector('tbody');
-            if (!tbody) {
-                this.debug('Table body not found');
-                return;
-            }
-            tbody.innerHTML = '';
-
-            // Get current account
-            const userAddress = await window.walletManager.getAccount();
-            if (!userAddress) {
-                this.debug('No account connected');
-                return;
-            }
-
-            // Get filter state
-            const showOnlyActive = this.container.querySelector('#fillable-orders-toggle')?.checked;
-
-            // Filter orders for the current user
-            let ordersToDisplay = Array.from(this.orders.values()).filter(order => 
-                order?.maker && userAddress && 
-                order.maker.toLowerCase() === userAddress.toLowerCase()
-            );
-
-            if (showOnlyActive) {
-                ordersToDisplay = ordersToDisplay.filter(order => 
-                    order.status !== 'Canceled' && order.status !== 'Filled'
-                );
-            }
-
-            // Get token details
-            const tokenAddresses = new Set();
-            ordersToDisplay.forEach(order => {
-                if (order?.sellToken) tokenAddresses.add(order.sellToken);
-                if (order?.buyToken) tokenAddresses.add(order.buyToken);
-            });
-
-            const tokenDetails = await this.getTokenDetails(Array.from(tokenAddresses));
-            const tokenDetailsMap = new Map();
-            tokenDetails.forEach((details, index) => {
-                if (details) {
-                    tokenDetailsMap.set(Array.from(tokenAddresses)[index], details);
-                }
-            });
-
-            // Sort orders based on current sort configuration
-            ordersToDisplay = ordersToDisplay.sort((a, b) => {
-                const direction = this.sortConfig.direction === 'asc' ? 1 : -1;
-                
-                switch (this.sortConfig.column) {
-                    case 'id':
-                        return (Number(a.id) - Number(b.id)) * direction;
-                    case 'sell':
-                        const sellTokenA = tokenDetailsMap.get(a.sellToken)?.symbol || '';
-                        const sellTokenB = tokenDetailsMap.get(b.sellToken)?.symbol || '';
-                        return sellTokenA.localeCompare(sellTokenB) * direction;
-                    case 'sellAmount':
-                        const sellAmountA = ethers.utils.formatUnits(a.sellAmount, tokenDetailsMap.get(a.sellToken)?.decimals || 18);
-                        const sellAmountB = ethers.utils.formatUnits(b.sellAmount, tokenDetailsMap.get(b.sellToken)?.decimals || 18);
-                        return (Number(sellAmountA) - Number(sellAmountB)) * direction;
-                    case 'buy':
-                        const buyTokenA = tokenDetailsMap.get(a.buyToken)?.symbol || '';
-                        const buyTokenB = tokenDetailsMap.get(b.buyToken)?.symbol || '';
-                        return buyTokenA.localeCompare(buyTokenB) * direction;
-                    case 'buyAmount':
-                        const buyAmountA = ethers.utils.formatUnits(a.buyAmount, tokenDetailsMap.get(a.buyToken)?.decimals || 18);
-                        const buyAmountB = ethers.utils.formatUnits(b.buyAmount, tokenDetailsMap.get(b.buyToken)?.decimals || 18);
-                        return (Number(buyAmountA) - Number(buyAmountB)) * direction;
-                    case 'expires':
-                        const expiryA = this.getExpiryTime(a.timestamp);
-                        const expiryB = this.getExpiryTime(b.timestamp);
-                        return (expiryA - expiryB) * direction;
-                    case 'status':
-                        return a.status.localeCompare(b.status) * direction;
-                    default:
-                        return 0;
-                }
-            });
-
-            // Check if we have any orders after filtering
-            if (!ordersToDisplay || ordersToDisplay.length === 0) {
-                this.debug('No orders to display after filtering');
-                tbody.innerHTML = `
-                    <tr>
-                        <td colspan="10" class="no-orders-message">
-                            <div class="placeholder-text">
-                                ${showOnlyActive ? 'No active orders found' : 'No orders found'}
-                            </div>
-                        </td>
-                    </tr>`;
-                return;
-            }
-
-            // Add orders to table
-            for (const order of ordersToDisplay) {
-                if (order) {
-                    const row = await this.createOrderRow(order, tokenDetailsMap);
-                    tbody.appendChild(row);
-                }
-            }
-        } catch (error) {
-            console.error('[MyOrders] Error refreshing orders view:', error);
-            throw error;
-        }
-    }
-
-    async setupTable() {
-        // Call parent's setupTable to get basic structure
-        await super.setupTable();
-        
-        // Update the table header to show maker's perspective
-        const thead = this.container.querySelector('thead tr');
-        if (thead) {
-            thead.innerHTML = `
-                <th data-sort="id">ID <span class="sort-icon">↕</span></th>
-                <th data-sort="buy">Sell <span class="sort-icon">↕</span></th>
-                <th data-sort="buyAmount" class="">Amount <span class="sort-icon">↕</span></th>
-                <th data-sort="sell">Buy <span class="sort-icon">↕</span></th>
-                <th data-sort="sellAmount">Amount <span class="sort-icon">↕</span></th>
-                <th data-sort="expires">Expires <span class="sort-icon">↕</span></th>
-                <th data-sort="status">Status <span class="sort-icon">↕</span></th>
-                <th>Taker</th>
-                <th>Action</th>
-            `;
-
-            // Re-add click handlers for sorting after updating innerHTML
-            thead.querySelectorAll('th[data-sort]').forEach(th => {
-                th.addEventListener('click', () => this.handleSort(th.dataset.sort));
-            });
-        }
-
-        // Replace the filter toggle text
-        const filterToggleSpan = this.container.querySelector('.filter-toggle span');
-        if (filterToggleSpan) {
-            filterToggleSpan.textContent = 'Show only active orders';
-        }
-    }
-}
\ No newline at end of file
diff --git a/otc/js/components/TakerOrders.js b/otc/js/components/TakerOrders.js
deleted file mode 100644
index b05e5de..0000000
--- a/otc/js/components/TakerOrders.js
+++ /dev/null
@@ -1,429 +0,0 @@
-import { ViewOrders } from './ViewOrders.js';
-import { ethers } from 'ethers';
-import { isDebugEnabled } from '../config.js';
-import { erc20Abi } from '../abi/erc20.js';
-
-export class TakerOrders extends ViewOrders {
-    constructor() {
-        super('taker-orders');
-        
-        // Initialize debug logger
-        this.debug = (message, ...args) => {
-            if (isDebugEnabled('TAKER_ORDERS')) {
-                console.log('[TakerOrders]', message, ...args);
-            }
-        };
-    }
-
-    async initialize(readOnlyMode = true) {
-        try {
-            this.debug('Initializing TakerOrders component');
-            
-            // Show connect wallet message if in read-only mode
-            if (readOnlyMode || !window.walletManager?.provider) {
-                this.container.innerHTML = `
-                    <div class="tab-content-wrapper">
-                        <h2>Orders for Me</h2>
-                        <p class="connect-prompt">Connect wallet to view orders targeted to you</p>
-                    </div>`;
-                return;
-            }
-
-            // Cleanup previous state
-            this.cleanup();
-            this.container.innerHTML = '';
-            
-            await this.setupTable();
-
-            // Get current account
-            let userAddress;
-            try {
-                userAddress = await window.walletManager.getAccount();
-            } catch (error) {
-                this.debug('Error getting account:', error);
-                userAddress = null;
-            }
-
-            if (!userAddress) {
-                this.debug('No account connected');
-                this.container.innerHTML = `
-                    <div class="tab-content-wrapper">
-                        <h2>Orders for Me</h2>
-                        <p class="connect-prompt">Connect wallet to view orders targeted to you</p>
-                    </div>`;
-                return;
-            }
-
-            // Get initial orders from cache and filter for taker
-            const cachedOrders = window.webSocket?.getOrders() || [];
-            const filteredOrders = cachedOrders.filter(order => 
-                order?.taker && userAddress && 
-                order.taker.toLowerCase() === userAddress.toLowerCase()
-            );
-
-            // Clear existing orders and add filtered ones
-            this.orders.clear();
-            if (filteredOrders.length > 0) {
-                this.debug('Loading orders from cache:', filteredOrders);
-                filteredOrders.forEach(order => {
-                    this.orders.set(order.id, order);
-                });
-            }
-
-            // Create table structure
-            const tbody = this.container.querySelector('tbody');
-            if (!tbody) {
-                this.debug('Table body not found');
-                return;
-            }
-
-            if (!filteredOrders.length) {
-                tbody.innerHTML = `
-                    <tr>
-                        <td colspan="10" class="no-orders-message">
-                            <div class="placeholder-text">
-                                No orders found where you are the designated taker
-                            </div>
-                        </td>
-                    </tr>`;
-            } else {
-                await this.refreshOrdersView();
-            }
-
-            // Setup WebSocket event handlers after initial load
-            this.setupWebSocket();
-
-        } catch (error) {
-            console.error('[TakerOrders] Initialization error:', error);
-            this.container.innerHTML = `
-                <div class="tab-content-wrapper">
-                    <h2>Orders for Me</h2>
-                    <p class="error-message">Failed to load orders. Please try again later.</p>
-                </div>`;
-        }
-    }
-
-    setupWebSocket() {
-        // Subscribe to order sync completion with taker filter
-        this.eventSubscriptions.add({
-            event: 'orderSyncComplete',
-            callback: async (orders) => {
-                const userAddress = await window.walletManager.getAccount();
-                this.orders.clear();
-                
-                // Filter orders where user is specifically set as taker
-                Object.values(orders)
-                    .filter(order => order.taker.toLowerCase() === userAddress.toLowerCase())
-                    .forEach(order => {
-                        this.orders.set(order.id, order);
-                    });
-                
-                this.refreshOrdersView().catch(error => {
-                    this.debug('Error refreshing orders after sync:', error);
-                });
-            }
-        });
-
-        // Subscribe to new orders
-        this.eventSubscriptions.add({
-            event: 'OrderCreated',
-            callback: async (orderData) => {
-                const userAddress = await window.walletManager.getAccount();
-                if (orderData.taker.toLowerCase() === userAddress.toLowerCase()) {
-                    this.debug('New order received:', orderData);
-                    this.orders.set(orderData.id, orderData);
-                    this.refreshOrdersView().catch(error => {
-                        this.debug('Error refreshing after new order:', error);
-                    });
-                }
-            }
-        });
-
-        // Subscribe to filled/canceled orders
-        ['OrderFilled', 'OrderCanceled'].forEach(event => {
-            this.eventSubscriptions.add({
-                event,
-                callback: (order) => {
-                    if (this.orders.has(order.id)) {
-                        this.debug(`Order ${event.toLowerCase()}:`, order);
-                        this.orders.get(order.id).status = event === 'OrderFilled' ? 'Filled' : 'Canceled';
-                        this.refreshOrdersView().catch(error => {
-                            this.debug('Error refreshing after order status change:', error);
-                        });
-                    }
-                }
-            });
-        });
-
-        // Register all subscriptions
-        this.eventSubscriptions.forEach(sub => {
-            window.webSocket.subscribe(sub.event, sub.callback);
-        });
-    }
-
-    async createOrderRow(order, tokenDetailsMap) {
-        const tr = await super.createOrderRow(order, tokenDetailsMap);
-        
-        // Replace the action column with fill button for active orders
-        const actionCell = tr.querySelector('.action-column');
-        const statusCell = tr.querySelector('.order-status');
-        
-        if (actionCell && statusCell) {
-            try {
-                const currentTime = Math.floor(Date.now() / 1000);
-                const orderTime = Number(order.timestamp);
-                const contract = await this.getContract();
-                
-                const orderExpiry = await contract.ORDER_EXPIRY();
-                const isExpired = currentTime > orderTime + orderExpiry.toNumber();
-                
-                if (!isExpired && order.status === 'Active') {
-                    actionCell.innerHTML = `
-                        <button class="fill-button" data-order-id="${order.id}">Fill Order</button>
-                    `;
-                    
-                    // Add click handler for fill button
-                    const fillButton = actionCell.querySelector('.fill-button');
-                    if (fillButton) {
-                        fillButton.addEventListener('click', () => this.fillOrder(order.id));
-                    }
-                } else {
-                    actionCell.innerHTML = '<span class="order-status"></span>';
-                }
-            } catch (error) {
-                console.error('[TakerOrders] Error in createOrderRow:', error);
-                actionCell.innerHTML = '<span class="order-status error">Error</span>';
-            }
-        }
-
-        return tr;
-    }
-
-    isOrderForTaker(order, userAddress) {
-        if (!order || !userAddress) return false;
-        return order.taker.toLowerCase() === userAddress.toLowerCase();
-    }
-
-    // Override fillOrder to add specific handling for taker orders
-    async fillOrder(orderId) {
-        const button = this.container.querySelector(`button[data-order-id="${orderId}"]`);
-        try {
-            if (button) {
-                button.disabled = true;
-                button.textContent = 'Filling...';
-            }
-
-            const order = this.orders.get(orderId);
-            this.debug('Order details:', order);
-
-            // Use ERC20 ABI for token contract
-            const buyToken = new ethers.Contract(
-                order.buyToken,
-                erc20Abi,
-                window.walletManager.getProvider()
-            );
-            
-            const userAddress = await window.walletManager.getAccount();
-            const balance = await buyToken.balanceOf(userAddress);
-            this.debug('Current balance:', balance.toString());
-            this.debug('Required amount:', order.buyAmount.toString());
-
-            if (balance.lt(order.buyAmount)) {
-                throw new Error(`Insufficient token balance. Have ${ethers.utils.formatEther(balance)}, need ${ethers.utils.formatEther(order.buyAmount)}`);
-            }
-
-            // Check allowance using ERC20 contract
-            const allowance = await buyToken.allowance(userAddress, this.contract.address);
-            this.debug('Current allowance:', allowance.toString());
-
-            if (allowance.lt(order.buyAmount)) {
-                this.showSuccess('Requesting token approval...');
-                
-                try {
-                    const approveTx = await buyToken.connect(window.walletManager.getProvider().getSigner()).approve(
-                        this.contract.address,
-                        order.buyAmount,
-                        {
-                            gasLimit: 70000,  // Standard gas limit for ERC20 approvals
-                            gasPrice: await window.walletManager.getProvider().getGasPrice()
-                        }
-                    );
-                    
-                    this.debug('Approval transaction sent:', approveTx.hash);
-                    await approveTx.wait();
-                    this.showSuccess('Token approval granted');
-                } catch (error) {
-                    if (error.code === 4001) { // MetaMask user rejected
-                        this.showError('Token approval was rejected');
-                        return;
-                    }
-                    throw error;
-                }
-            }
-
-            // Fill order with standard gas limit
-            const tx = await this.contract.fillOrder(orderId, {
-                gasLimit: 300000,  // Standard gas limit for fill orders
-                gasPrice: await window.walletManager.getProvider().getGasPrice()
-            });
-            
-            this.debug('Fill order transaction sent:', tx.hash);
-            this.showSuccess('Order fill transaction submitted');
-            
-            await tx.wait();
-            this.debug('Transaction confirmed');
-
-        } catch (error) {
-            this.debug('Fill order error details:', {
-                message: error.message,
-                code: error.code,
-                data: error?.error?.data,
-                reason: error?.reason,
-                stack: error.stack
-            });
-            
-            let errorMessage = 'Failed to fill order: ';
-            
-            // Try to decode the error
-            if (error?.error?.data) {
-                try {
-                    const decodedError = this.contract.interface.parseError(error.error.data);
-                    errorMessage += `${decodedError.name}: ${decodedError.args}`;
-                    this.debug('Decoded error:', decodedError);
-                } catch (e) {
-                    // If we can't decode the error, fall back to basic messages
-                    if (error.code === -32603) {
-                        errorMessage += 'Transaction would fail. Check order status and token approvals.';
-                    } else {
-                        errorMessage += error.message;
-                    }
-                }
-            }
-            
-            this.showError(errorMessage);
-        } finally {
-            if (button) {
-                button.disabled = false;
-                button.textContent = 'Fill Order';
-            }
-        }
-    }
-
-    async refreshOrdersView() {
-        try {
-            // Get contract instance first
-            this.contract = await this.getContract();
-            if (!this.contract) {
-                throw new Error('Contract not initialized');
-            }
-
-            // Clear existing orders from table
-            const tbody = this.container.querySelector('tbody');
-            if (!tbody) {
-                console.warn('[TakerOrders] Table body not found');
-                return;
-            }
-            tbody.innerHTML = '';
-
-            // Get filter and pagination state
-            const showOnlyFillable = this.container.querySelector('#fillable-orders-toggle')?.checked;
-            const pageSize = parseInt(this.container.querySelector('#page-size-select').value);
-
-            // Filter orders if necessary
-            let ordersToDisplay = Array.from(this.orders.values());
-            if (showOnlyFillable) {
-                ordersToDisplay = await Promise.all(ordersToDisplay.map(async order => {
-                    const status = this.getOrderStatus(order, this.getExpiryTime(order.timestamp));
-                    return status === 'Active' ? order : null;
-                }));
-                ordersToDisplay = ordersToDisplay.filter(order => order !== null);
-            }
-
-            // Apply pagination if not viewing all
-            const totalOrders = ordersToDisplay.length;
-            if (pageSize !== -1) {
-                const startIndex = (this.currentPage - 1) * pageSize;
-                ordersToDisplay = ordersToDisplay.slice(startIndex, startIndex + pageSize);
-            }
-
-            // Update pagination controls
-            this.updatePaginationControls(totalOrders);
-
-            // Check if we have any orders after filtering
-            if (!ordersToDisplay || ordersToDisplay.length === 0) {
-                tbody.innerHTML = `
-                    <tr>
-                        <td colspan="10" class="no-orders-message">
-                            <div class="placeholder-text">
-                                ${showOnlyFillable ? 'No fillable orders found' : 'No orders found where you are the designated taker'}
-                            </div>
-                        </td>
-                    </tr>`;
-                return;
-            }
-
-            // Get token details and create rows
-            const tokenAddresses = new Set();
-            ordersToDisplay.forEach(order => {
-                if (order?.sellToken) tokenAddresses.add(order.sellToken.toLowerCase());
-                if (order?.buyToken) tokenAddresses.add(order.buyToken.toLowerCase());
-            });
-
-            const tokenDetails = await this.getTokenDetails(Array.from(tokenAddresses));
-            const tokenDetailsMap = new Map();
-            Array.from(tokenAddresses).forEach((address, index) => {
-                if (tokenDetails[index]) {
-                    tokenDetailsMap.set(address, tokenDetails[index]);
-                }
-            });
-
-            // Create and append order rows
-            for (const order of ordersToDisplay) {
-                try {
-                    const orderWithLowercase = {
-                        ...order,
-                        sellToken: order.sellToken.toLowerCase(),
-                        buyToken: order.buyToken.toLowerCase()
-                    };
-                    const row = await this.createOrderRow(orderWithLowercase, tokenDetailsMap);
-                    if (row) {
-                        tbody.appendChild(row);
-                    }
-                } catch (error) {
-                    console.error('[TakerOrders] Error creating row for order:', order.id, error);
-                }
-            }
-
-        } catch (error) {
-            this.debug('Error refreshing orders view:', error);
-            throw error;
-        }
-    }
-
-    async setupTable() {
-        // Call parent's setupTable to get basic structure
-        await super.setupTable();
-        
-        // Keep the same structure as ViewOrders.js since it's already in taker's perspective
-        const thead = this.container.querySelector('thead tr');
-        if (thead) {
-            thead.innerHTML = `
-                <th data-sort="id">ID <span class="sort-icon">↕</span></th>
-                <th data-sort="buy">Buy <span class="sort-icon">↕</span></th>
-                <th data-sort="buyAmount">Amount <span class="sort-icon">↕</span></th>
-                <th data-sort="sell">Sell <span class="sort-icon">↕</span></th>
-                <th data-sort="sellAmount">Amount <span class="sort-icon">↕</span></th>
-                <th data-sort="expires">Expires <span class="sort-icon">↕</span></th>
-                <th data-sort="status">Status <span class="sort-icon">↕</span></th>
-                <th>Taker</th>
-                <th>Action</th>
-            `;
-        }
-
-        // Update filter toggle text
-        const filterToggleSpan = this.container.querySelector('.filter-toggle span');
-        if (filterToggleSpan) {
-            filterToggleSpan.textContent = 'Show only fillable orders';
-        }
-    }
-}
diff --git a/otc/js/components/ViewOrders.js b/otc/js/components/ViewOrders.js
deleted file mode 100644
index 40f476d..0000000
--- a/otc/js/components/ViewOrders.js
+++ /dev/null
@@ -1,1146 +0,0 @@
-import { BaseComponent } from './BaseComponent.js';
-import { ethers } from 'ethers';
-import { erc20Abi } from '../abi/erc20.js';
-import { ContractError, CONTRACT_ERRORS } from '../errors/ContractErrors.js';
-import { isDebugEnabled } from '../config.js';
-
-export class ViewOrders extends BaseComponent {
-    constructor(containerId = 'view-orders') {
-        super(containerId);
-        this.orders = new Map();
-        this.tokenCache = new Map();
-        this.provider = new ethers.providers.Web3Provider(window.ethereum);
-        this.currentPage = 1;
-        this.setupErrorHandling();
-        this.eventSubscriptions = new Set();
-        this.expiryTimers = new Map();
-        
-        // Initialize debug logger with VIEW_ORDERS flag
-        this.debug = (message, ...args) => {
-            if (isDebugEnabled('VIEW_ORDERS')) {
-                console.log('[ViewOrders]', message, ...args);
-            }
-        };
-    }
-
-    setupErrorHandling() {
-        if (!window.webSocket) {
-            if (!this._retryAttempt) {
-                this.debug('WebSocket not available, waiting for initialization...');
-                this._retryAttempt = true;
-            }
-            setTimeout(() => this.setupErrorHandling(), 1000);
-            return;
-        }
-        this._retryAttempt = false;
-
-        window.webSocket.subscribe('error', (error) => {
-            let userMessage = 'An error occurred';
-            
-            if (error instanceof ContractError) {
-                switch(error.code) {
-                    case CONTRACT_ERRORS.INVALID_ORDER.code:
-                        userMessage = 'This order no longer exists';
-                        break;
-                    case CONTRACT_ERRORS.INSUFFICIENT_ALLOWANCE.code:
-                        userMessage = 'Please approve tokens before proceeding';
-                        break;
-                    case CONTRACT_ERRORS.UNAUTHORIZED.code:
-                        userMessage = 'You are not authorized to perform this action';
-                        break;
-                    case CONTRACT_ERRORS.EXPIRED_ORDER.code:
-                        userMessage = 'This order has expired';
-                        break;
-                    default:
-                        userMessage = error.message;
-                }
-            }
-
-            this.showError(userMessage);
-            this.debug('Order error:', {
-                code: error.code,
-                message: error.message,
-                details: error.details
-            });
-        });
-    }
-
-    async initialize(readOnlyMode = true) {
-        try {
-            this.debug('Initializing ViewOrders component');
-            // Cleanup previous state
-            this.cleanup();
-            this.container.innerHTML = '';
-            
-            await this.setupTable();
-            
-            // Wait for WebSocket to be initialized
-            if (!window.webSocket?.isInitialized) {
-                this.debug('Waiting for WebSocket initialization...');
-                await new Promise(resolve => {
-                    const checkInterval = setInterval(() => {
-                        if (window.webSocket?.isInitialized) {
-                            clearInterval(checkInterval);
-                            resolve();
-                        }
-                    }, 100);
-                });
-            }
-            
-            // Setup WebSocket event handlers
-            await this.setupWebSocket();
-
-            // Get initial orders from cache
-            const cachedOrders = window.webSocket.getOrders();
-            if (cachedOrders && cachedOrders.length > 0) {
-                this.debug('Loading orders from cache:', cachedOrders);
-                // Clear existing orders before adding new ones
-                this.orders.clear();
-                cachedOrders.forEach(order => {
-                    this.orders.set(order.id, order);
-                });
-            }
-
-            // Always call refreshOrdersView to show orders or empty state
-            await this.refreshOrdersView();
-
-        } catch (error) {
-            console.error('[ViewOrders] Initialization error:', error);
-            throw error;
-        }
-    }
-
-    async setupWebSocket() {
-        this.debug('Setting up WebSocket subscriptions');
-        
-        // Clear existing subscriptions
-        this.eventSubscriptions.clear();
-        if (window.webSocket) {
-            window.webSocket.subscribers.forEach((_, event) => {
-                window.webSocket.unsubscribe(event, this);
-            });
-        }
-        
-        // Add new subscriptions
-        this.eventSubscriptions.add({
-            event: 'orderSyncComplete',
-            callback: (orders) => {
-                this.debug('Received order sync:', orders);
-                this.orders.clear();
-                Object.entries(orders).forEach(([orderId, orderData]) => {
-                    this.orders.set(Number(orderId), {
-                        id: Number(orderId),
-                        ...orderData
-                    });
-                });
-                this.refreshOrdersView().catch(console.error);
-            }
-        });
-
-        this.eventSubscriptions.add({
-            event: 'OrderCreated',
-            callback: (orderData) => {
-                this.debug('New order received:', orderData);
-                this.orders.set(Number(orderData.id), orderData);
-                this.refreshOrdersView().catch(error => {
-                    console.error('[ViewOrders] Error refreshing view after new order:', error);
-                });
-            }
-        });
-
-        this.eventSubscriptions.add({
-            event: 'OrderFilled',
-            callback: (orderData) => {
-                this.debug('Order filled:', orderData);
-                if (this.orders.has(Number(orderData.id))) {
-                    this.orders.get(Number(orderData.id)).status = 'Filled';
-                    this.refreshOrdersView().catch(error => {
-                        console.error('[ViewOrders] Error refreshing view after order fill:', error);
-                    });
-                }
-            }
-        });
-
-        this.eventSubscriptions.add({
-            event: 'OrderCanceled',
-            callback: (orderData) => {
-                this.debug('Order canceled:', orderData);
-                if (this.orders.has(Number(orderData.id))) {
-                    this.orders.get(Number(orderData.id)).status = 'Canceled';
-                    this.refreshOrdersView().catch(error => {
-                        console.error('[ViewOrders] Error refreshing view after order cancel:', error);
-                    });
-                }
-            }
-        });
-
-        if (window.webSocket) {
-            this.debug('Registering WebSocket subscriptions');
-            this.eventSubscriptions.forEach(sub => {
-                window.webSocket.subscribe(sub.event, sub.callback);
-            });
-        }
-    }
-
-    async refreshOrdersView() {
-        this.debug('Refreshing orders view');
-        try {
-            // Get contract instance first
-            this.contract = await this.getContract();
-            
-            // Clear existing orders from table
-            const tbody = this.container.querySelector('tbody');
-            if (!tbody) {
-                this.debug('Table body not found');
-                return;
-            }
-            tbody.innerHTML = '';
-
-            // Get filter and pagination state
-            const showOnlyFillable = this.container.querySelector('#fillable-orders-toggle')?.checked;
-            const pageSize = parseInt(this.container.querySelector('#page-size-select').value);
-            
-            // Filter orders if necessary
-            let ordersToDisplay = Array.from(this.orders.values());
-            
-            // Debug log the orders
-            this.debug('Orders before filtering:', ordersToDisplay);
-
-            if (showOnlyFillable && this.contract) {
-                ordersToDisplay = await Promise.all(ordersToDisplay.map(async order => {
-                    const canFill = await this.canFillOrder(order);
-                    return canFill ? order : null;
-                }));
-                ordersToDisplay = ordersToDisplay.filter(order => order !== null);
-            }
-
-            // Get token details only if we have orders
-            let tokenDetailsMap = new Map();
-            if (ordersToDisplay.length > 0) {
-                const tokenAddresses = new Set();
-                ordersToDisplay.forEach(order => {
-                    if (order?.sellToken) tokenAddresses.add(order.sellToken.toLowerCase());
-                    if (order?.buyToken) tokenAddresses.add(order.buyToken.toLowerCase());
-                });
-
-                const tokenDetails = await this.getTokenDetails(Array.from(tokenAddresses));
-                if (tokenDetails) {
-                    Array.from(tokenAddresses).forEach((address, index) => {
-                        if (tokenDetails[index]) {
-                            tokenDetailsMap.set(address.toLowerCase(), tokenDetails[index]);
-                        }
-                    });
-                }
-            }
-
-            // Debug log the orders
-            this.debug('Orders after filtering:', ordersToDisplay);
-
-            // Sort the filtered orders first
-            ordersToDisplay = ordersToDisplay.sort((a, b) => {
-                const direction = this.sortConfig.direction === 'asc' ? 1 : -1;
-                
-                switch (this.sortConfig.column) {
-                    case 'id':
-                        return (Number(a.id) - Number(b.id)) * direction;
-                    case 'sell':
-                        const sellTokenA = tokenDetailsMap.get(a.sellToken?.toLowerCase())?.symbol || 'Unknown';
-                        const sellTokenB = tokenDetailsMap.get(b.sellToken?.toLowerCase())?.symbol || 'Unknown';
-                        return sellTokenA.localeCompare(sellTokenB) * direction;
-                    case 'sellAmount':
-                        const sellAmountA = ethers.utils.formatUnits(a.sellAmount, tokenDetailsMap.get(a.sellToken?.toLowerCase())?.decimals || 18);
-                        const sellAmountB = ethers.utils.formatUnits(b.sellAmount, tokenDetailsMap.get(b.sellToken?.toLowerCase())?.decimals || 18);
-                        return (Number(sellAmountA) - Number(sellAmountB)) * direction;
-                    case 'buy':
-                        const buyTokenA = tokenDetailsMap.get(a.buyToken?.toLowerCase())?.symbol || 'Unknown';
-                        const buyTokenB = tokenDetailsMap.get(b.buyToken?.toLowerCase())?.symbol || 'Unknown';
-                        return buyTokenA.localeCompare(buyTokenB) * direction;
-                    case 'buyAmount':
-                        const buyAmountA = ethers.utils.formatUnits(a.buyAmount, tokenDetailsMap.get(a.buyToken?.toLowerCase())?.decimals || 18);
-                        const buyAmountB = ethers.utils.formatUnits(b.buyAmount, tokenDetailsMap.get(b.buyToken?.toLowerCase())?.decimals || 18);
-                        return (Number(buyAmountA) - Number(buyAmountB)) * direction;
-                    case 'created':
-                        return (Number(a.timestamp) - Number(b.timestamp)) * direction;
-                    case 'expires':
-                        const expiryA = this.getExpiryTime(a.timestamp);
-                        const expiryB = this.getExpiryTime(b.timestamp);
-                        return (expiryA - expiryB) * direction;
-                    case 'status':
-                        const statusA = this.getOrderStatus(a, this.getExpiryTime(a.timestamp));
-                        const statusB = this.getOrderStatus(b, this.getExpiryTime(b.timestamp));
-                        return statusA.localeCompare(statusB) * direction;
-                    default:
-                        return 0;
-                }
-            });
-
-            // Debug log the orders after sorting
-            this.debug('Orders after sorting:', ordersToDisplay);
-
-            // Apply pagination if not viewing all
-            const totalOrders = ordersToDisplay.length;
-            if (pageSize !== -1) {
-                const startIndex = (this.currentPage - 1) * pageSize;
-                ordersToDisplay = ordersToDisplay.slice(startIndex, startIndex + pageSize);
-            }
-
-            // Update pagination controls
-            this.updatePaginationControls(totalOrders);
-
-            // Check if we have any orders after filtering
-            if (!ordersToDisplay || ordersToDisplay.length === 0) {
-                tbody.innerHTML = `
-                    <tr>
-                        <td colspan="10" class="no-orders-message">
-                            <div class="placeholder-text">
-                                ${showOnlyFillable ? 'No fillable orders found' : 'No orders found'}
-                            </div>
-                        </td>
-                    </tr>`;
-                return;
-            }
-
-            // Add sorted orders to table
-            for (const order of ordersToDisplay) {
-                if (order) {
-                    const row = await this.createOrderRow(order, tokenDetailsMap);
-                    tbody.appendChild(row);
-                }
-            }
-        } catch (error) {
-            console.error('[ViewOrders] Error refreshing orders view:', error);
-            const tbody = this.container.querySelector('tbody');
-            if (tbody) {
-                tbody.innerHTML = `
-                    <tr>
-                        <td colspan="10" class="no-orders-message">
-                            <div class="placeholder-text">
-                                ${!this.contract ? 
-                                    'Connect wallet to view orders' : 
-                                    'Unable to load orders. Please try again later.'}
-                            </div>
-                        </td>
-                    </tr>`;
-            }
-        }
-    }
-
-    showReadOnlyMessage() {
-        this.container.innerHTML = `
-            <div class="tab-content-wrapper">
-                <h2>Orders</h2>
-                <p class="connect-prompt">Connect wallet to view orders</p>
-            </div>`;
-    }
-
-    updateOrderStatus(orderId, status) {
-        const row = this.container.querySelector(`tr[data-order-id="${orderId}"]`);
-        if (row) {
-            const statusCell = row.querySelector('.order-status');
-            if (statusCell) {
-                statusCell.textContent = status;
-                statusCell.className = `order-status status-${status.toLowerCase()}`;
-            }
-        }
-    }
-
-    async addOrderToTable(order, tokenDetailsMap) {
-        try {
-            const sellTokenDetails = tokenDetailsMap.get(order.sellToken);
-            const buyTokenDetails = tokenDetailsMap.get(order.buyToken);
-
-            const row = document.createElement('tr');
-            row.setAttribute('data-order-id', order.id);
-            
-            row.innerHTML = `
-                <td>${order.id}</td>
-                <td>${order.maker}</td>
-                <td>${order.taker || 'Any'}</td>
-                <td>${sellTokenDetails.symbol} (${order.sellToken})</td>
-                <td>${ethers.utils.formatUnits(order.sellAmount, sellTokenDetails.decimals)}</td>
-                <td>${buyTokenDetails.symbol} (${order.buyToken})</td>
-                <td>${ethers.utils.formatUnits(order.buyAmount, buyTokenDetails.decimals)}</td>
-                <td>${new Date(order.timestamp * 1000).toLocaleString()}</td>
-                <td class="order-status status-${order.status.toLowerCase()}">${order.status}</td>
-            `;
-
-            const tableBody = this.container.querySelector('tbody');
-            if (tableBody) {
-                tableBody.appendChild(row);
-            }
-        } catch (error) {
-            console.error('[ViewOrders] Error adding order to table:', error);
-            throw error;
-        }
-    }
-
-    removeOrderFromTable(orderId) {
-        const row = this.tbody.querySelector(`tr[data-order-id="${orderId}"]`);
-        if (row) {
-            row.remove();
-            this.orders.delete(orderId.toString());
-        }
-    }
-
-    async setupTable() {
-        const tableContainer = this.createElement('div', 'table-container');
-        
-        // Create top pagination controls with dropdown
-        const createTopControls = () => `
-            <div class="pagination-controls">
-                <select id="page-size-select" class="page-size-select">
-                    <option value="10">10 per page</option>
-                    <option value="25">25 per page</option>
-                    <option value="50" selected>50 per page</option>
-                    <option value="100">100 per page</option>
-                    <option value="-1">View all</option>
-                </select>
-                
-                <div class="pagination-buttons">
-                    <button class="pagination-button prev-page" title="Previous page">
-                        ←
-                    </button>
-                    <span class="page-info">Page 1 of 1</span>
-                    <button class="pagination-button next-page" title="Next page">
-                        →
-                    </button>
-                </div>
-            </div>
-        `;
-
-        // Create bottom pagination controls without dropdown
-        const createBottomControls = () => `
-            <div class="pagination-controls">
-                <div class="pagination-buttons">
-                    <button class="pagination-button prev-page" title="Previous page">
-                        ←
-                    </button>
-                    <span class="page-info">Page 1 of 1</span>
-                    <button class="pagination-button next-page" title="Next page">
-                        
-                    </button>
-                </div>
-            </div>
-        `;
-        
-        // Add top filter controls with pagination
-        const filterControls = this.createElement('div', 'filter-controls');
-        filterControls.innerHTML = `
-            <div class="filter-row">
-                <label class="filter-toggle">
-                    <input type="checkbox" id="fillable-orders-toggle">
-                    <span>Show only fillable orders</span>
-                </label>
-                ${createTopControls()}
-            </div>
-        `;
-        
-        tableContainer.appendChild(filterControls);
-        
-        // Add table
-        const table = this.createElement('table', 'orders-table');
-        
-        const thead = this.createElement('thead');
-        thead.innerHTML = `
-            <tr>
-                <th data-sort="id">ID <span class="sort-icon">↕</span></th>
-                <th data-sort="buy">Buy <span class="sort-icon">↕</span></th>
-                <th data-sort="buyAmount">Amount <span class="sort-icon">↕</span></th>
-                <th data-sort="sell">Sell <span class="sort-icon">↕</span></th>
-                <th data-sort="sellAmount">Amount <span class="sort-icon">↕</span></th>
-                <th data-sort="expires">Expires <span class="sort-icon">↕</span></th>
-                <th data-sort="status">Status <span class="sort-icon">↕</span></th>
-                <th>Taker</th>
-                <th>Action</th>
-            </tr>
-        `;
-        
-        // Add click handlers for sorting
-        thead.querySelectorAll('th[data-sort]').forEach(th => {
-            th.addEventListener('click', () => this.handleSort(th.dataset.sort));
-        });
-        
-        table.appendChild(thead);
-        table.appendChild(this.createElement('tbody'));
-        tableContainer.appendChild(table);
-        
-        // Add bottom pagination
-        const bottomControls = this.createElement('div', 'filter-controls bottom-controls');
-        bottomControls.innerHTML = `
-            <div class="filter-row">
-                ${createBottomControls()}
-            </div>
-        `;
-        tableContainer.appendChild(bottomControls);
-        
-        // Add event listeners
-        const addPaginationListeners = (container, isTop) => {
-            if (isTop) {
-                const pageSizeSelect = container.querySelector('.page-size-select');
-                if (pageSizeSelect) {
-                    pageSizeSelect.addEventListener('change', () => {
-                        this.currentPage = 1;
-                        this.refreshOrdersView();
-                    });
-                }
-            }
-            
-            const prevButton = container.querySelector('.prev-page');
-            const nextButton = container.querySelector('.next-page');
-            
-            if (prevButton) {
-                prevButton.addEventListener('click', () => {
-                    if (this.currentPage > 1) {
-                        this.currentPage--;
-                        this.refreshOrdersView();
-                    }
-                });
-            }
-            
-            if (nextButton) {
-                nextButton.addEventListener('click', () => {
-                    const totalPages = this.getTotalPages();
-                    if (this.currentPage < totalPages) {
-                        this.currentPage++;
-                        this.refreshOrdersView();
-                    }
-                });
-            }
-        };
-        
-        // Add listeners to both top and bottom controls
-        addPaginationListeners(filterControls, true);
-        addPaginationListeners(bottomControls, false);
-        
-        const toggle = filterControls.querySelector('#fillable-orders-toggle');
-        toggle.addEventListener('change', () => this.refreshOrdersView());
-        
-        this.container.appendChild(tableContainer);
-
-        // Initialize sorting state
-        this.sortConfig = {
-            column: 'id',
-            direction: 'asc'
-        };
-    }
-
-    handleSort(column) {
-        this.debug('Sorting by column:', column);
-        
-        // Toggle direction if clicking same column
-        if (this.sortConfig.column === column) {
-            this.sortConfig.direction = this.sortConfig.direction === 'asc' ? 'desc' : 'asc';
-        } else {
-            this.sortConfig.column = column;
-            this.sortConfig.direction = 'asc';
-        }
-
-        // Update sort icons and active states
-        const headers = this.container.querySelectorAll('th[data-sort]');
-        headers.forEach(header => {
-            const icon = header.querySelector('.sort-icon');
-            if (header.dataset.sort === column) {
-                header.classList.add('active-sort');
-                icon.textContent = this.sortConfig.direction === 'asc' ? '↑' : '↓';
-            } else {
-                header.classList.remove('active-sort');
-                icon.textContent = '↕';
-            }
-        });
-
-        // Refresh the view with new sort
-        this.refreshOrdersView();
-    }
-
-    formatAddress(address) {
-        return `${address.slice(0, 6)}...${address.slice(-4)}`;
-    }
-
-    formatTimestamp(timestamp) {
-        const date = new Date(Number(timestamp) * 1000);
-        return date.toLocaleDateString('en-US', {
-            month: 'numeric',
-            day: 'numeric',
-            hour: 'numeric',
-            minute: '2-digit'
-        });
-    }
-
-    async formatExpiry(timestamp) {
-        try {
-            const contract = await this.getContract();
-            const orderExpiry = (await contract.ORDER_EXPIRY()).toNumber();  // 420 seconds (7 minutes)
-            // Don't add gracePeriod here since we only want to show when it expires
-            
-            const expiryTime = Number(timestamp) + orderExpiry;  // Just use orderExpiry
-            const now = Math.floor(Date.now() / 1000);
-            const timeLeft = expiryTime - now;
-
-            this.debug('Expiry calculation:', {
-                timestamp,
-                orderExpiry,
-                expiryTime,
-                now,
-                timeLeft,
-                timeLeftMinutes: timeLeft / 60
-            });
-
-            if (timeLeft <= 0) {
-                return 'Expired';
-            }
-
-            const minutes = Math.ceil(timeLeft / 60);
-            return `${minutes}m`;
-        } catch (error) {
-            this.debug('Error formatting expiry:', error);
-            return 'Unknown';
-        }
-    }
-
-    setupEventListeners() {
-        this.tbody.addEventListener('click', async (e) => {
-            if (e.target.classList.contains('fill-button')) {
-                const orderId = e.target.dataset.orderId;
-                await this.fillOrder(orderId);
-            }
-        });
-    }
-
-    setupFilters() {
-        // Will implement filtering in next iteration
-    }
-
-    async checkAllowance(tokenAddress, owner, amount) {
-        try {
-            const tokenContract = new ethers.Contract(
-                tokenAddress,
-                ['function allowance(address owner, address spender) view returns (uint256)'],
-                this.provider
-            );
-            const allowance = await tokenContract.allowance(owner, this.contract.address);
-            return allowance.gte(amount);
-        } catch (error) {
-            console.error('[ViewOrders] Error checking allowance:', error);
-            return false;
-        }
-    }
-
-    async fillOrder(orderId) {
-        const button = this.container.querySelector(`button[data-order-id="${orderId}"]`);
-        try {
-            if (button) {
-                button.disabled = true;
-                button.textContent = 'Filling...';
-            }
-
-            this.debug('Starting fill order process for orderId:', orderId);
-            const order = this.orders.get(orderId);
-            this.debug('Order details:', order);
-
-            // Create token contract instance with full ERC20 ABI
-            // Use buyToken since the taker is selling what the maker wants to buy
-            const takerToken = new ethers.Contract(
-                order.buyToken,  // This is what the taker needs to sell (maker wants to buy)
-                erc20Abi,
-                this.provider
-            );
-            
-            const userAddress = await window.walletManager.getAccount();
-            
-            // Check balance and allowance for what taker needs to sell
-            const balance = await takerToken.balanceOf(userAddress);
-            const allowance = await takerToken.allowance(userAddress, this.contract.address);
-
-            if (balance.lt(order.buyAmount)) {
-                throw new Error(`Insufficient token balance. Have ${ethers.utils.formatEther(balance)}, need ${ethers.utils.formatEther(order.buyAmount)}`);
-            }
-
-            if (allowance.lt(order.buyAmount)) {
-                this.showSuccess('Requesting token approval...');
-                
-                try {
-                    const approveTx = await takerToken.connect(this.provider.getSigner()).approve(
-                        this.contract.address,
-                        order.buyAmount,  // Amount the taker needs to sell (maker's buyAmount)
-                        {
-                            gasLimit: 70000,
-                            gasPrice: await this.provider.getGasPrice()
-                        }
-                    );
-                    
-                    this.debug('Approval transaction sent:', approveTx.hash);
-                    await approveTx.wait();
-                    this.showSuccess('Token approval granted');
-                } catch (error) {
-                    this.debug('Approval failed:', error);
-                    throw new Error('Token approval failed. Please try again.');
-                }
-            }
-
-            // Use standard gas limit for fill order
-            const tx = await this.contract.fillOrder(orderId, {
-                gasLimit: 300000,  // Standard gas limit for fill orders
-                gasPrice: await this.provider.getGasPrice()
-            });
-            
-            this.debug('Transaction sent:', tx.hash);
-            await tx.wait();
-            this.debug('Transaction confirmed');
-
-            // Update order status in memory
-            const orderToUpdate = this.orders.get(Number(orderId));
-            if (orderToUpdate) {
-                orderToUpdate.status = 'Filled';
-                this.orders.set(Number(orderId), orderToUpdate);
-                await this.refreshOrdersView();
-            }
-
-            this.showSuccess(`Order ${orderId} filled successfully!`);
-        } catch (error) {
-            this.debug('Fill order error details:', {
-                message: error.message,
-                code: error.code,
-                data: error?.error?.data,
-                reason: error?.reason,
-                stack: error.stack
-            });
-            
-            let errorMessage = 'Failed to fill order: ';
-            
-            // Try to decode the error
-            if (error?.error?.data) {
-                try {
-                    const decodedError = this.contract.interface.parseError(error.error.data);
-                    errorMessage += `${decodedError.name}: ${decodedError.args}`;
-                    this.debug('Decoded error:', decodedError);
-                } catch (e) {
-                    // If we can't decode the error, fall back to basic messages
-                    if (error.code === -32603) {
-                        errorMessage += 'Transaction would fail. Check order status and token approvals.';
-                    } else {
-                        errorMessage += error.message;
-                    }
-                }
-            }
-            
-            this.showError(errorMessage);
-        } finally {
-            if (button) {
-                button.disabled = false;
-                button.textContent = 'Fill Order';
-            }
-        }
-    }
-
-    getReadableError(error) {
-        // Reuse the same error handling from CreateOrder
-        switch (error.code) {
-            case 'ACTION_REJECTED':
-                return 'Transaction was rejected by user';
-            case 'INSUFFICIENT_FUNDS':
-                return 'Insufficient funds for transaction';
-            case -32603:
-                return 'Network error. Please check your connection';
-            case 'UNPREDICTABLE_GAS_LIMIT':
-                return 'Error estimating gas. The transaction may fail';
-            default:
-                return error.reason || error.message || 'Error filling order';
-        }
-    }
-
-    async getOrderDetails(orderId) {
-        try {
-            const contract = await this.getContract();
-            if (!contract) {
-                throw new Error('Contract not initialized');
-            }
-
-            const order = await contract.orders(orderId);
-            return {
-                id: orderId,
-                maker: order.maker,
-                taker: order.taker,
-                sellToken: order.sellToken,
-                sellAmount: order.sellAmount,
-                buyToken: order.buyToken,
-                buyAmount: order.buyAmount,
-                timestamp: order.timestamp,
-                status: order.status,
-                orderCreationFee: order.orderCreationFee,
-                tries: order.tries
-            };
-        } catch (error) {
-            console.error('[ViewOrders] Error getting order details:', error);
-            throw error;
-        }
-    }
-
-    cleanup() {
-        // Clear all expiry timers
-        if (this.expiryTimers) {
-            this.expiryTimers.forEach(timerId => clearInterval(timerId));
-            this.expiryTimers.clear();
-        }
-        
-        // Clear existing subscriptions
-        this.eventSubscriptions.forEach(sub => {
-            if (window.webSocket) {
-                window.webSocket.unsubscribe(sub.event, sub.callback);
-            }
-        });
-        this.eventSubscriptions.clear();
-        
-        // Clear orders map
-        this.orders.clear();
-        
-        // Clear the table
-        if (this.container) {
-            const tbody = this.container.querySelector('tbody');
-            if (tbody) {
-                tbody.innerHTML = '';
-            }
-        }
-    }
-
-    async createOrderRow(order, tokenDetailsMap) {
-        const tr = this.createElement('tr');
-        tr.dataset.orderId = order.id.toString();
-        tr.dataset.timestamp = order.timestamp;
-        tr.dataset.status = order.status;
-
-        const sellTokenDetails = tokenDetailsMap.get(order.sellToken);
-        const buyTokenDetails = tokenDetailsMap.get(order.buyToken);
-        const canFill = await this.canFillOrder(order);
-        const expiryTime = await this.getExpiryTime(order.timestamp);
-        const status = this.getOrderStatus(order, expiryTime);
-        const formattedExpiry = await this.formatExpiry(order.timestamp);
-        
-        // Get current account first
-        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
-        const currentAccount = accounts[0]?.toLowerCase();
-        const isUserOrder = order.maker?.toLowerCase() === currentAccount;
-
-        // Format taker display
-        const takerDisplay = order.taker === ethers.constants.AddressZero 
-            ? '<span class="open-order">Open to All</span>'
-            : `<span class="targeted-order" title="${order.taker}">Private</span>`;
-
-        tr.innerHTML = `
-            <td>${order.id}</td>
-            <td>${sellTokenDetails?.symbol || 'Unknown'}</td>
-            <td>${ethers.utils.formatUnits(order.sellAmount, sellTokenDetails?.decimals || 18)}</td>
-            <td>${buyTokenDetails?.symbol || 'Unknown'}</td>
-            <td>${ethers.utils.formatUnits(order.buyAmount, buyTokenDetails?.decimals || 18)}</td>
-            <td>${formattedExpiry}</td>
-            <td class="order-status">${status}</td>
-            <td class="taker-column">${takerDisplay}</td>
-            <td class="action-column">${canFill ? 
-                `<button class="fill-button" data-order-id="${order.id}">Fill Order</button>` : 
-                isUserOrder ?
-                '<span class="your-order">Your Order</span>' : 
-                ''
-            }</td>`;
-
-        // Add click handler for fill button
-        const fillButton = tr.querySelector('.fill-button');
-        if (fillButton) {
-            fillButton.addEventListener('click', () => this.fillOrder(order.id));
-        }
-
-        // Start the expiry timer for this row
-        this.startExpiryTimer(tr);
-        
-        return tr;
-    }
-
-    async getContractExpiryTimes() {
-        try {
-            const contract = await this.getContract();
-            if (!contract) {
-                throw new Error('Contract not initialized');
-            }
-            const orderExpiry = await contract.ORDER_EXPIRY();
-            const gracePeriod = await contract.GRACE_PERIOD();
-            return {
-                orderExpiry: orderExpiry.toNumber(),
-                gracePeriod: gracePeriod.toNumber()
-            };
-        } catch (error) {
-            console.error('[ViewOrders] Error fetching expiry times:', error);
-            throw error;
-        }
-    }
-
-    async getExpiryTime(timestamp) {
-        try {
-            const { orderExpiry, gracePeriod } = await this.getContractExpiryTimes();
-            return (Number(timestamp) + orderExpiry + gracePeriod) * 1000; // Convert to milliseconds
-        } catch (error) {
-            console.error('[ViewOrders] Error calculating expiry time:', error);
-            return Number(timestamp) * 1000; // Fallback to original timestamp
-        }
-    }
-
-    getOrderStatus(order, currentTime, orderExpiry, gracePeriod) {
-        this.debug('Order timing:', {
-            currentTime,
-            orderTime: order.timestamp,
-            orderExpiry,  // 420 seconds (7 minutes)
-            gracePeriod   // 420 seconds (7 minutes)
-        });
-
-        // Check explicit status first
-        if (order.status === 'Canceled') return 'Canceled';
-        if (order.status === 'Filled') return 'Filled';
-
-        // Then check timing
-        const totalExpiry = orderExpiry + gracePeriod;
-        const orderTime = Number(order.timestamp);
-
-        if (currentTime > orderTime + totalExpiry) {
-            this.debug('Order not active: Past grace period');
-            return 'Expired';
-        }
-        if (currentTime > orderTime + orderExpiry) {
-            this.debug('Order status: Awaiting Clean');
-            return 'Expired';
-        }
-
-        this.debug('Order status: Active');
-        return 'Active';
-    }
-
-    async canFillOrder(order) {
-        try {
-            // Get current account
-            const accounts = await window.ethereum.request({ 
-                method: 'eth_accounts' 
-            });
-            if (!accounts || accounts.length === 0) {
-                this.debug('No wallet connected');
-                return false;
-            }
-            const currentAccount = accounts[0].toLowerCase();
-
-            // Convert status from number to string if needed
-            const statusMap = ['Active', 'Filled', 'Canceled'];
-            const orderStatus = typeof order.status === 'number' ? 
-                statusMap[order.status] : order.status;
-            
-            if (orderStatus !== 'Active') {
-                this.debug('Order not active:', orderStatus);
-                return false;
-            }
-
-            // Check if order is expired - using the contract's ORDER_EXPIRY
-            const contract = await this.getContract();
-            const orderExpiry = (await contract.ORDER_EXPIRY()).toNumber();
-            const now = Math.floor(Date.now() / 1000);
-            const expiryTime = Number(order.timestamp) + orderExpiry;
-
-            if (now >= expiryTime) {
-                this.debug('Order expired', {
-                    now,
-                    timestamp: order.timestamp,
-                    orderExpiry,
-                    expiryTime
-                });
-                return false;
-            }
-
-            // Check if user is the maker (can't fill own orders)
-            if (order.maker?.toLowerCase() === currentAccount) {
-                this.debug('User is maker of order');
-                return false;
-            }
-
-            // Check if order is open to all or if user is the specified taker
-            const isOpenOrder = order.taker === ethers.constants.AddressZero;
-            const isSpecifiedTaker = order.taker?.toLowerCase() === currentAccount;
-            const canFill = isOpenOrder || isSpecifiedTaker;
-
-            this.debug('Can fill order:', {
-                isOpenOrder,
-                isSpecifiedTaker,
-                canFill
-            });
-            
-            return canFill;
-        } catch (error) {
-            console.error('[ViewOrders] Error in canFillOrder:', error);
-            return false;
-        }
-    }
-
-    getTotalPages() {
-        const pageSize = parseInt(this.container.querySelector('#page-size-select').value);
-        if (pageSize === -1) return 1; // View all
-        return Math.ceil(this.orders.size / pageSize);
-    }
-
-    updatePaginationControls(filteredOrdersCount) {
-        const pageSize = parseInt(this.container.querySelector('.page-size-select').value);
-        const updateControls = (container) => {
-            const prevButton = container.querySelector('.prev-page');
-            const nextButton = container.querySelector('.next-page');
-            const pageInfo = container.querySelector('.page-info');
-            const pageSizeSelect = container.querySelector('.page-size-select');
-            
-            if (pageSize === -1) {
-                prevButton.disabled = true;
-                nextButton.disabled = true;
-                pageInfo.textContent = `Showing all ${filteredOrdersCount} orders`;
-                return;
-            }
-            
-            const totalPages = Math.ceil(filteredOrdersCount / pageSize);
-            
-            prevButton.disabled = this.currentPage === 1;
-            nextButton.disabled = this.currentPage === totalPages;
-            
-            pageInfo.textContent = `Page ${this.currentPage} of ${totalPages}`;
-            
-            // Keep page size selects in sync
-            if (pageSizeSelect) {
-                pageSizeSelect.value = pageSize;
-            }
-        };
-        
-        // Update both top and bottom controls
-        const controls = this.container.querySelectorAll('.filter-controls');
-        controls.forEach(updateControls);
-    }
-
-    async refreshOrders() {
-        try {
-            this.debug('Refreshing orders view');
-            const orders = this.webSocket.getOrders() || [];
-            this.debug('Orders from WebSocket:', orders);
-
-            const contract = await this.getContract();
-            if (!contract) {
-                throw new Error('Contract not initialized');
-            }
-
-            const orderExpiry = (await contract.ORDER_EXPIRY()).toNumber();
-            const gracePeriod = (await contract.GRACE_PERIOD()).toNumber();
-            const currentTime = Math.floor(Date.now() / 1000);
-
-            // Show all orders including cleaned ones
-            const filteredOrders = orders.filter(order => {
-                const status = this.getOrderStatus(order, currentTime, orderExpiry, gracePeriod);
-                this.debug('Processing order:', {
-                    orderId: order.id,
-                    status,
-                    timestamp: order.timestamp,
-                    currentTime,
-                    orderExpiry,
-                    gracePeriod
-                });
-                return true; // Show all orders
-            });
-
-            this.debug('Orders after filtering:', filteredOrders);
-
-            // Sort orders by timestamp descending
-            const sortedOrders = [...filteredOrders].sort((a, b) => b.timestamp - a.timestamp);
-            await this.displayOrders(sortedOrders);
-
-        } catch (error) {
-            this.debug('Error refreshing orders:', error);
-            this.showError('Failed to refresh orders');
-        }
-    }
-
-    async displayOrders(orders) {
-        try {
-            const contract = await this.getContract();
-            const orderExpiry = (await contract.ORDER_EXPIRY()).toNumber();
-            this.debug('Order expiry from contract:', {
-                orderExpiry,
-                inMinutes: orderExpiry / 60
-            });
-            
-            // ... rest of the code ...
-        } catch (error) {
-            this.debug('Error displaying orders:', error);
-            throw error;
-        }
-    }
-
-    formatExpiryTime(timestamp, orderExpiry) {
-        const expiryTime = timestamp + orderExpiry;
-        const now = Math.floor(Date.now() / 1000);
-        const timeLeft = expiryTime - now;
-        
-        this.debug('Expiry calculation:', {
-            timestamp,
-            orderExpiry,
-            expiryTime,
-            now,
-            timeLeft,
-            timeLeftMinutes: timeLeft / 60
-        });
-        
-        if (timeLeft <= 0) {
-            return 'Expired';
-        }
-        
-        const minutes = Math.ceil(timeLeft / 60);
-        return `${minutes}m`;
-    }
-
-    startExpiryTimer(row) {
-        // Clear any existing timer
-        const existingTimer = this.expiryTimers?.get(row.dataset.orderId);
-        if (existingTimer) {
-            clearInterval(existingTimer);
-        }
-
-        // Initialize timers Map if not exists
-        if (!this.expiryTimers) {
-            this.expiryTimers = new Map();
-        }
-
-        const updateExpiry = async () => {
-            const expiresCell = row.querySelector('td:nth-child(6)'); // Expires column
-            if (!expiresCell) return;
-
-            const timestamp = row.dataset.timestamp;
-            const status = row.dataset.status;
-
-            // For cancelled orders, show 'Cancelled' instead of expiry time
-            if (status === 'Canceled') {
-                expiresCell.textContent = 'Cancelled';
-                return;
-            }
-            
-            // For filled orders, show 'Filled' instead of expiry time
-            if (status === 'Filled') {
-                expiresCell.textContent = 'Filled';
-                return;
-            }
-
-            const currentTime = Math.floor(Date.now() / 1000);
-            const contract = await this.getContract();
-            const orderExpiry = (await contract.ORDER_EXPIRY()).toNumber();
-            const expiryTime = Number(timestamp) + orderExpiry;
-            const timeDiff = expiryTime - currentTime;
-
-            // Format time difference
-            const absHours = Math.floor(Math.abs(timeDiff) / 3600);
-            const absMinutes = Math.floor((Math.abs(timeDiff) % 3600) / 60);
-            const sign = timeDiff < 0 ? '-' : '';
-            const newExpiryText = `${sign}${absHours}h ${absMinutes}m`;
-
-            if (expiresCell.textContent !== newExpiryText) {
-                expiresCell.textContent = newExpiryText;
-            }
-        };
-
-        // Update immediately and then every minute
-        updateExpiry();
-        const timerId = setInterval(updateExpiry, 60000); // Update every minute
-        this.expiryTimers.set(row.dataset.orderId, timerId);
-    }
-}
diff --git a/otc/js/components/WalletUI.js b/otc/js/components/WalletUI.js
deleted file mode 100644
index 9b2fa35..0000000
--- a/otc/js/components/WalletUI.js
+++ /dev/null
@@ -1,251 +0,0 @@
-import { ethers } from 'ethers';
-import { BaseComponent } from './BaseComponent.js';
-import { walletManager, isDebugEnabled } from '../config.js';
-
-export class WalletUI extends BaseComponent {
-    constructor() {
-        super('wallet-container');
-        
-        this.debug = (message, ...args) => {
-            if (isDebugEnabled('WALLET_UI')) {
-                console.log('[WalletUI]', message, ...args);
-            }
-        };
-        
-        try {
-            this.debug('Constructor starting...');
-            this.initializeElements();
-            this.init();
-            this.debug('Constructor completed');
-        } catch (error) {
-            console.error('[WalletUI] Error in constructor:', error);
-        }
-    }
-
-    initializeElements() {
-        try {
-            this.debug('Initializing elements...');
-            
-            // Initialize DOM elements with error checking
-            this.connectButton = document.getElementById('walletConnect');
-            this.debug('Connect button found:', this.connectButton);
-            
-            this.disconnectButton = document.getElementById('walletDisconnect');
-            this.debug('Disconnect button found:', this.disconnectButton);
-            
-            this.walletInfo = document.getElementById('walletInfo');
-            this.debug('Wallet info found:', this.walletInfo);
-            
-            this.accountAddress = document.getElementById('accountAddress');
-            this.debug('Account address found:', this.accountAddress);
-
-            if (!this.connectButton || !this.disconnectButton || !this.walletInfo || !this.accountAddress) {
-                throw new Error('Required wallet UI elements not found');
-            }
-
-            // Add click listener with explicit binding
-            const handleClick = (e) => {
-                this.debug('Connect button clicked!', e);
-                this.handleConnectClick(e);
-            };
-
-            this.connectButton.addEventListener('click', handleClick);
-            this.debug('Click listener added to connect button');
-
-        } catch (error) {
-            console.error('Error in initializeElements:', error);
-        }
-    }
-
-    async handleConnectClick(e) {
-        try {
-            this.debug('Handle connect click called');
-            e.preventDefault();
-            const result = await this.connectWallet();
-            this.debug('Connect result:', result);
-            if (result && result.account) {
-                this.updateUI(result.account);
-                // Trigger app-level wallet connection handler
-                if (window.app && typeof window.app.handleWalletConnect === 'function') {
-                    await window.app.handleWalletConnect(result.account);
-                }
-            }
-        } catch (error) {
-            console.error('[WalletUI] Error in handleConnectClick:', error);
-        }
-    }
-
-    async connectWallet() {
-        try {
-            this.debug('Connecting wallet...');
-            const result = await walletManager.connect();
-            return result;
-        } catch (error) {
-            console.error('[WalletUI] Failed to connect wallet:', error);
-            this.showError("Failed to connect wallet: " + error.message);
-            return null;
-        }
-    }
-
-    async init() {
-        try {
-            this.debug('Starting init...');
-            
-            if (typeof window.ethereum === 'undefined') {
-                console.error('[WalletUI] MetaMask is not installed!');
-                return false;
-            }
-
-            // Setup event listeners
-            this.setupEventListeners();
-            
-            // Check if already connected
-            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
-            if (accounts && accounts.length > 0) {
-                this.debug('Found existing connection, connecting...');
-                await this.connectWallet();
-            }
-            
-            return true;
-        } catch (error) {
-            console.error('[WalletUI] Error in init:', error);
-            throw error;
-        }
-    }
-
-    setupEventListeners() {
-        // Update disconnect button handler
-        this.disconnectButton.addEventListener('click', async (e) => {
-            e.preventDefault();
-            this.debug('Disconnect button clicked');
-            try {
-                // Clear our app's connection state
-                await walletManager.disconnect();
-                
-                // Reset UI
-                this.showConnectButton();
-                this.accountAddress.textContent = '';
-                
-                // Clear any cached provider state
-                if (window.ethereum) {
-                    // Remove all listeners to ensure clean slate
-                    window.ethereum.removeAllListeners();
-                    // Re-initialize necessary listeners
-                    this.setupEventListeners();
-                }
-                
-                // Update tab visibility
-                if (window.app && typeof window.app.updateTabVisibility === 'function') {
-                    window.app.updateTabVisibility(false);
-                }
-                
-                // Show more detailed message to user
-                const message = "Wallet disconnected from this site. For complete security:\n" +
-                              "1. Open MetaMask extension\n" +
-                              "2. Click on your account icon\n" +
-                              "3. Select 'Lock' or 'Disconnect this site'";
-                
-                if (window.app && typeof window.app.showSuccess === 'function') {
-                    window.app.showSuccess(message);
-                }
-                
-                // Trigger app-level disconnect handler
-                if (window.app && typeof window.app.handleWalletDisconnect === 'function') {
-                    window.app.handleWalletDisconnect();
-                }
-            } catch (error) {
-                console.error('[WalletUI] Error disconnecting:', error);
-            }
-        });
-
-        // Setup wallet manager listeners
-        walletManager.addListener((event, data) => {
-            this.debug('Wallet event:', event, data);
-            switch (event) {
-                case 'connect':
-                    this.debug('Connect event received');
-                    this.updateUI(data.account);
-                    if (window.app && typeof window.app.handleWalletConnect === 'function') {
-                        window.app.handleWalletConnect(data.account);
-                    }
-                    break;
-                case 'disconnect':
-                    this.debug('Disconnect event received');
-                    this.showConnectButton();
-                    break;
-                case 'accountsChanged':
-                    this.debug('Account change event received');
-                    this.updateUI(data.account);
-                    break;
-                case 'chainChanged':
-                    this.debug('Chain change event received');
-                    this.updateNetworkBadge(data.chainId);
-                    break;
-            }
-        });
-    }
-
-    updateUI(account) {
-        try {
-            this.debug('Updating UI with account:', account);
-            if (!account) {
-                this.debug('No account provided, showing connect button');
-                this.showConnectButton();
-                return;
-            }
-
-            const shortAddress = `${account.slice(0, 6)}...${account.slice(-4)}`;
-            this.debug('Setting short address:', shortAddress);
-            
-            this.connectButton.classList.add('hidden');
-            this.walletInfo.classList.remove('hidden');
-            this.accountAddress.textContent = shortAddress;
-            
-            if (walletManager.chainId) {
-                this.updateNetworkBadge(walletManager.chainId);
-            }
-            
-            this.debug('UI updated successfully');
-        } catch (error) {
-            console.error('[WalletUI] Error in updateUI:', error);
-        }
-    }
-
-    showConnectButton() {
-        try {
-            this.debug('Showing connect button');
-            this.connectButton.classList.remove('hidden');
-            this.walletInfo.classList.add('hidden');
-            this.debug('Connect button shown');
-        } catch (error) {
-            console.error('[WalletUI] Error in showConnectButton:', error);
-        }
-    }
-
-    updateNetworkBadge(chainId) {
-        try {
-            this.debug('Updating network badge for chain:', chainId);
-            const networkBadge = document.querySelector('.network-badge');
-            if (!networkBadge) {
-                console.error('[WalletUI] Network badge element not found');
-                return;
-            }
-
-            const decimalChainId = parseInt(chainId, 16).toString();
-            this.debug('Decimal chain ID:', decimalChainId);
-
-            if (decimalChainId === "80002") {
-                networkBadge.textContent = "Amoy";
-                networkBadge.classList.remove('wrong-network');
-                networkBadge.classList.add('connected');
-            } else {
-                networkBadge.textContent = "Wrong Network";
-                networkBadge.classList.add('wrong-network');
-                networkBadge.classList.remove('connected');
-            }
-            this.debug('Network badge updated');
-        } catch (error) {
-            console.error('[WalletUI] Error updating network badge:', error);
-        }
-    }
-} 
\ No newline at end of file
diff --git a/otc/js/config.js b/otc/js/config.js
deleted file mode 100644
index 68352f7..0000000
--- a/otc/js/config.js
+++ /dev/null
@@ -1,385 +0,0 @@
-import { abi as CONTRACT_ABI } from './abi/OTCSwap.js';
-import { ethers } from 'ethers';
-
-const networkConfig = {
-    "80002": {
-        name: "Amoy",
-        displayName: "Amoy Testnet",
-        contractAddress: "0x8d65112BA50B600c6495c4C199561AD74752D7eE", // 0x3e6326657B7130613c943D013EC84cE1F33027Ba 0x8d65112BA50B600c6495c4C199561AD74752D7eE
-        contractABI: CONTRACT_ABI,
-        explorer: "https://www.oklink.com/amoy",
-        rpcUrl: "https://rpc.ankr.com/polygon_amoy",
-        fallbackRpcUrls: [
-            "https://rpc.ankr.com/polygon_amoy",
-            "https://polygon-amoy.blockpi.network/v1/rpc/public",
-            "wss://polygon-amoy-bor-rpc.publicnode.com",
-            "https://polygon-amoy.public.blastapi.io"
-        ],
-        chainId: "0x13882",
-        nativeCurrency: {
-            name: "POLYGON Ecosystem Token",
-            symbol: "POL",
-            decimals: 18
-        },
-        wsUrl: 'wss://polygon-amoy-bor.publicnode.com'
-    },
-};
-
-export const getAllNetworks = () => Object.values(networkConfig);
-
-export const DEBUG_CONFIG = {
-    APP: false,
-    WEBSOCKET: false,
-    COMPONENTS: false,
-    WALLET: false,
-    VIEW_ORDERS: false,
-    CREATE_ORDER: false,
-    MY_ORDERS: false,
-    TAKER_ORDERS: false,
-    CLEANUP_ORDERS: false,
-    WALLET_UI: false,
-    BASE_COMPONENT: false,
-    // Add more specific flags as needed
-};
-
-export const isDebugEnabled = (component) => {
-    // Check if debug mode is forced via localStorage
-    const localDebug = localStorage.getItem('debug');
-    if (localDebug) {
-        const debugSettings = JSON.parse(localDebug);
-        return debugSettings[component] ?? DEBUG_CONFIG[component];
-    }
-    return DEBUG_CONFIG[component];
-};
-
-export class WalletManager {
-    constructor() {
-        this.listeners = new Set();
-        this.isConnecting = false;
-        this.account = null;
-        this.chainId = null;
-        this.isConnected = false;
-        this.onAccountChange = null;
-        this.onChainChange = null;
-        this.onConnect = null;
-        this.onDisconnect = null;
-        this.provider = null;
-        this.signer = null;
-        this.contract = null;
-        this.contractAddress = networkConfig["80002"].contractAddress;
-        this.contractABI = CONTRACT_ABI;
-        this.isInitialized = false;
-        this.debug = (message, ...args) => {
-            if (isDebugEnabled('WALLET')) {
-                console.log('[WalletManager]', message, ...args);
-            }
-        };
-    }
-
-    async init() {
-        try {
-            this.debug('Starting initialization...');
-            
-            if (typeof window.ethereum === 'undefined') {
-                throw new Error("MetaMask is not installed!");
-            }
-
-            this.provider = new ethers.providers.Web3Provider(window.ethereum);
-            
-            // Set contract configuration
-            const networkCfg = getNetworkConfig();
-            this.contractAddress = networkCfg.contractAddress;
-            this.contractABI = CONTRACT_ABI;
-            
-            this.debug('Provider initialized');
-            this.debug('Contract config:', {
-                address: this.contractAddress,
-                hasABI: !!this.contractABI
-            });
-
-            // Setup event listeners
-            window.ethereum.on('accountsChanged', this.handleAccountsChanged.bind(this));
-            window.ethereum.on('chainChanged', this.handleChainChanged.bind(this));
-            window.ethereum.on('connect', this.handleConnect.bind(this));
-            window.ethereum.on('disconnect', this.handleDisconnect.bind(this));
-
-            // Check if already connected
-            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
-            if (accounts.length > 0) {
-                await this.initializeSigner(accounts[0]);
-                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
-                this.handleChainChanged(chainId);
-            }
-
-            this.isInitialized = true;
-            this.debug('Initialization complete');
-        } catch (error) {
-            console.error("[WalletManager] Error in init:", error);
-            throw error;
-        }
-    }
-
-    async checkConnection() {
-        try {
-            const accounts = await this.provider.listAccounts();
-            return accounts.length > 0;
-        } catch (error) {
-            console.error('[WalletManager] Connection check failed:', error);
-            return false;
-        }
-    }
-
-    async initializeSigner(account) {
-        try {
-            this.signer = this.provider.getSigner();
-            await this.initializeContract();
-            return this.signer;
-        } catch (error) {
-            console.error('[WalletManager] Error initializing signer:', error);
-            throw error;
-        }
-    }
-
-    async initializeContract() {
-        try {
-            const networkConfig = getNetworkConfig();
-            this.contract = new ethers.Contract(
-                networkConfig.contractAddress,
-                CONTRACT_ABI,
-                this.signer
-            );
-            
-            console.log('[WalletManager] Contract initialized with ABI:', 
-                this.contract.interface.format());
-            return this.contract;
-        } catch (error) {
-            console.error('[WalletManager] Error initializing contract:', error);
-            throw error;
-        }
-    }
-
-    async connect() {
-        if (!window.ethereum) {
-            throw new Error("MetaMask is not installed!");
-        }
-
-        this.isConnecting = true;
-        try {
-            this.debug('Requesting accounts...');
-            const accounts = await window.ethereum.request({ 
-                method: 'eth_requestAccounts' 
-            });
-            
-            this.debug('Accounts received:', accounts);
-            
-            const chainId = await window.ethereum.request({ 
-                method: 'eth_chainId' 
-            });
-            this.debug('Chain ID:', chainId);
-
-            const decimalChainId = parseInt(chainId, 16).toString();
-            this.debug('Decimal Chain ID:', decimalChainId);
-            
-            if (decimalChainId !== "80002") {
-                await this.switchToAmoy();
-            }
-
-            this.account = accounts[0];
-            this.chainId = chainId;
-            this.isConnected = true;
-
-            this.debug('Notifying listeners of connection');
-            this.notifyListeners('connect', {
-                account: this.account,
-                chainId: this.chainId
-            });
-
-            const result = await this.initializeSigner(this.account);
-            return {
-                account: this.account,
-                chainId: this.chainId
-            };
-        } catch (error) {
-            this.debug('Connection error:', error);
-            throw error;
-        } finally {
-            this.isConnecting = false;
-        }
-    }
-
-    async switchToAmoy() {
-        const config = networkConfig["80002"];
-        try {
-            await window.ethereum.request({
-                method: 'wallet_switchEthereumChain',
-                params: [{ chainId: config.chainId }],
-            });
-        } catch (error) {
-            if (error.code === 4902) {
-                await window.ethereum.request({
-                    method: 'wallet_addEthereumChain',
-                    params: [{
-                        chainId: config.chainId,
-                        chainName: config.name,
-                        nativeCurrency: config.nativeCurrency,
-                        rpcUrls: [config.rpcUrl, ...config.fallbackRpcUrls],
-                        blockExplorerUrls: [config.explorer]
-                    }],
-                });
-            } else {
-                throw error;
-            }
-        }
-    }
-
-    handleAccountsChanged(accounts) {
-        this.debug('Accounts changed:', accounts);
-        if (accounts.length === 0) {
-            this.account = null;
-            this.isConnected = false;
-            this.debug('No accounts, triggering disconnect');
-            this.notifyListeners('disconnect', {});
-        } else if (accounts[0] !== this.account) {
-            this.account = accounts[0];
-            this.isConnected = true;
-            this.debug('New account:', this.account);
-            this.notifyListeners('accountsChanged', { account: this.account });
-        }
-    }
-
-    handleChainChanged(chainId) {
-        this.chainId = chainId;
-        this.notifyListeners('chainChanged', { chainId });
-        if (this.onChainChange) {
-            this.onChainChange(chainId);
-        }
-        
-        const decimalChainId = parseInt(chainId, 16).toString();
-        if (decimalChainId !== "80002") {
-            this.switchToAmoy();
-        }
-    }
-
-    handleConnect(connectInfo) {
-        if (this.onConnect) {
-            this.onConnect(connectInfo);
-        }
-    }
-
-    handleDisconnect(error) {
-        this.isConnected = false;
-        if (this.onDisconnect) {
-            this.onDisconnect(error);
-        }
-    }
-
-    // Utility methods
-    getAccount() {
-        return this.account;
-    }
-
-    isWalletConnected() {
-        return this.isConnected;
-    }
-
-    disconnect() {
-        this.account = null;
-        this.isConnected = false;
-        if (this.onDisconnect) {
-            this.onDisconnect();
-        }
-    }
-
-    addListener(callback) {
-        this.listeners.add(callback);
-    }
-
-    removeListener(callback) {
-        this.listeners.delete(callback);
-    }
-
-    notifyListeners(event, data) {
-        this.listeners.forEach(callback => callback(event, data));
-    }
-
-    // Add getter methods
-    getSigner() {
-        return this.signer;
-    }
-
-    getContract() {
-        return this.contract;
-    }
-
-    getProvider() {
-        return this.provider;
-    }
-
-    async initializeProvider() {
-        try {
-            const config = getNetworkConfig();
-            let provider;
-            let error;
-
-            // Try main RPC URL first
-            try {
-                provider = new ethers.providers.JsonRpcProvider(config.rpcUrl);
-                await provider.getNetwork();
-                return provider;
-            } catch (e) {
-                error = e;
-            }
-
-            // Try fallback URLs
-            for (const rpcUrl of config.fallbackRpcUrls) {
-                try {
-                    provider = new ethers.providers.JsonRpcProvider(rpcUrl);
-                    await provider.getNetwork();
-                    return provider;
-                } catch (e) {
-                    error = e;
-                }
-            }
-
-            throw error;
-        } catch (error) {
-            console.error('[WalletManager] Error initializing provider:', error);
-            throw error;
-        }
-    }
-
-    // Add method to check initialization status
-    isWalletInitialized() {
-        return this.isInitialized;
-    }
-
-    // Add method to get contract configuration
-    getContractConfig() {
-        return {
-            address: this.contractAddress,
-            abi: this.contractABI
-        };
-    }
-
-    getFallbackProviders() {
-        const config = getNetworkConfig();
-        return config.fallbackRpcUrls.map(url => 
-            new ethers.providers.JsonRpcProvider(url)
-        );
-    }
-
-    // Add this new method
-    async getCurrentAddress() {
-        if (!this.signer) {
-            throw new Error('No signer available');
-        }
-        return await this.signer.getAddress();
-    }
-
-    isConnected() {
-        return this.account !== null && this.chainId !== null;
-    }
-}
-
-export const walletManager = new WalletManager();
-export const getNetworkConfig = () => networkConfig["80002"];
\ No newline at end of file
diff --git a/otc/js/errors/ContractErrors.js b/otc/js/errors/ContractErrors.js
deleted file mode 100644
index 27bd970..0000000
--- a/otc/js/errors/ContractErrors.js
+++ /dev/null
@@ -1,27 +0,0 @@
-export class ContractError extends Error {
-    constructor(message, code, details = {}) {
-        super(message);
-        this.name = 'ContractError';
-        this.code = code;
-        this.details = details;
-    }
-}
-
-export const CONTRACT_ERRORS = {
-    INVALID_ORDER: {
-        code: 'INVALID_ORDER',
-        message: 'This order no longer exists'
-    },
-    INSUFFICIENT_ALLOWANCE: {
-        code: 'INSUFFICIENT_ALLOWANCE',
-        message: 'Please approve tokens before proceeding'
-    },
-    UNAUTHORIZED: {
-        code: 'UNAUTHORIZED',
-        message: 'You are not authorized to perform this action'
-    },
-    EXPIRED_ORDER: {
-        code: 'EXPIRED_ORDER',
-        message: 'This order has expired'
-    }
-}; 
\ No newline at end of file
diff --git a/otc/js/services/EventSync.js b/otc/js/services/EventSync.js
deleted file mode 100644
index e69de29..0000000
diff --git a/otc/js/services/OrderManager.js b/otc/js/services/OrderManager.js
deleted file mode 100644
index e69de29..0000000
diff --git a/otc/js/services/WebSocket.js b/otc/js/services/WebSocket.js
deleted file mode 100644
index 61a58fd..0000000
--- a/otc/js/services/WebSocket.js
+++ /dev/null
@@ -1,384 +0,0 @@
-import { ethers } from 'ethers';
-import { getNetworkConfig, isDebugEnabled } from '../config.js';
-
-export class WebSocketService {
-    constructor() {
-        this.provider = null;
-        this.subscribers = new Map();
-        this.reconnectAttempts = 0;
-        this.maxReconnectAttempts = 5;
-        this.reconnectDelay = 1000;
-        this.orderCache = new Map();
-        this.isInitialized = false;
-        this.contractAddress = null;
-        this.contractABI = null;
-        this.contract = null;
-        
-        this.debug = (message, ...args) => {
-            if (isDebugEnabled('WEBSOCKET')) {
-                console.log('[WebSocket]', message, ...args);
-            }
-        };
-    }
-
-    async initialize() {
-        try {
-            if (this.isInitialized) return true;
-            this.debug('Starting initialization...');
-            
-            const config = getNetworkConfig();
-            this.debug('Network config loaded, connecting to:', config.wsUrl);
-            
-            this.contractAddress = config.contractAddress;
-            this.contractABI = config.contractABI;
-            
-            if (!this.contractABI) {
-                throw new Error('Contract ABI not found in network config');
-            }
-            
-            this.provider = new ethers.providers.WebSocketProvider(config.wsUrl);
-            
-            // Wait for provider to be ready
-            await this.provider.ready;
-            this.debug('Provider ready');
-
-            this.contract = new ethers.Contract(
-                this.contractAddress,
-                this.contractABI,
-                this.provider
-            );
-
-            this.debug('Contract initialized, starting order sync...');
-            await this.syncAllOrders(this.contract);
-            this.debug('Setting up event listeners...');
-            await this.setupEventListeners(this.contract);
-            
-            this.isInitialized = true;
-            this.debug('Initialization complete');
-            this.reconnectAttempts = 0;
-            
-            return true;
-        } catch (error) {
-            this.debug('Initialization failed:', error);
-            return this.reconnect();
-        }
-    }
-
-    async setupEventListeners(contract) {
-        try {
-            this.debug('Setting up event listeners for contract:', contract.address);
-            
-            // Add connection state tracking
-            this.provider.on("connect", () => {
-                this.debug('Provider connected');
-            });
-            
-            this.provider.on("disconnect", (error) => {
-                this.debug('Provider disconnected:', error);
-                this.reconnect();
-            });
-
-            // Test event subscription
-            const filter = contract.filters.OrderCreated();
-            this.debug('Created filter:', filter);
-            
-            // Listen for new blocks to ensure connection is alive
-            this.provider.on("block", (blockNumber) => {
-                this.debug('New block received:', blockNumber);
-            });
-
-            contract.on("OrderCreated", (...args) => {
-                try {
-                    this.debug('OrderCreated event received (raw):', args);
-                    const [orderId, maker, taker, sellToken, sellAmount, buyToken, buyAmount, timestamp, fee, event] = args;
-                    
-                    const orderData = {
-                        id: orderId.toNumber(),
-                        maker,
-                        taker,
-                        sellToken,
-                        sellAmount,
-                        buyToken,
-                        buyAmount,
-                        timestamp: timestamp.toNumber(),
-                        orderCreationFee: fee,
-                        status: 'Active'
-                    };
-                    
-                    this.debug('Processed OrderCreated data:', orderData);
-                    
-                    // Update cache
-                    this.orderCache.set(orderId.toNumber(), orderData);
-                    this.debug('Cache updated:', Array.from(this.orderCache.entries()));
-                    
-                    // Log subscribers before notification
-                    this.debug('Current subscribers for OrderCreated:', 
-                        this.subscribers.get("OrderCreated")?.size || 0);
-                    
-                    this.notifySubscribers("OrderCreated", orderData);
-                } catch (error) {
-                    this.debug('Error in OrderCreated handler:', error);
-                }
-            });
-
-            contract.on("OrderFilled", (...args) => {
-                const [orderId] = args;
-                const orderIdNum = orderId.toNumber();
-                const order = this.orderCache.get(orderIdNum);
-                if (order) {
-                    order.status = 'Filled';
-                    this.orderCache.set(orderIdNum, order);
-                    this.debug('Cache updated for filled order:', order);
-                    this.notifySubscribers("OrderFilled", order);
-                }
-            });
-
-            contract.on("OrderCanceled", (orderId, maker, timestamp, event) => {
-                const order = this.orderCache.get(orderId.toNumber());
-                if (order) {
-                    order.status = 'Canceled';
-                    this.updateOrderCache(orderId.toNumber(), order);
-                    this.notifySubscribers("OrderCanceled", order);
-                }
-            });
-            
-            this.debug('Event listeners setup complete');
-        } catch (error) {
-            this.debug('Error setting up event listeners:', error);
-        }
-    }
-
-    async syncAllOrders(contract) {
-        try {
-            this.debug('Starting order sync with contract:', contract.address);
-            
-            let nextOrderId = 0;
-            try {
-                nextOrderId = await contract.nextOrderId();
-                this.debug('nextOrderId result:', nextOrderId.toString());
-            } catch (error) {
-                this.debug('nextOrderId call failed, using default value:', error);
-            }
-
-            // Clear existing cache before sync
-            this.orderCache.clear();
-            
-            // Sync all orders that have a valid maker address
-            for (let i = 0; i < nextOrderId; i++) {
-                try {
-                    const order = await contract.orders(i);
-                    // Only filter out zero-address makers (non-existent orders)
-                    if (order.maker !== ethers.constants.AddressZero) {
-                        const orderData = {
-                            id: i,
-                            maker: order.maker,
-                            taker: order.taker,
-                            sellToken: order.sellToken,
-                            sellAmount: order.sellAmount,
-                            buyToken: order.buyToken,
-                            buyAmount: order.buyAmount,
-                            timestamp: order.timestamp.toNumber(),
-                            status: ['Active', 'Filled', 'Canceled'][order.status], // Map enum to string
-                            orderCreationFee: order.orderCreationFee,
-                            tries: order.tries
-                        };
-                        this.orderCache.set(i, orderData);
-                        this.debug('Added order to cache:', orderData);
-                    }
-                } catch (error) {
-                    this.debug(`Failed to read order ${i}:`, error);
-                    continue;
-                }
-            }
-            
-            this.debug('Order sync complete. Cache size:', this.orderCache.size);
-            this.notifySubscribers('orderSyncComplete', Object.fromEntries(this.orderCache));
-            
-        } catch (error) {
-            this.debug('Order sync failed:', error);
-            this.orderCache.clear();
-            this.notifySubscribers('orderSyncComplete', {});
-        }
-    }
-
-    getOrders(filterStatus = null) {
-        try {
-            this.debug('Getting orders with filter:', filterStatus);
-            const orders = Array.from(this.orderCache.values());
-            
-            if (filterStatus) {
-                return orders.filter(order => order.status === filterStatus);
-            }
-            
-            return orders;
-        } catch (error) {
-            this.debug('Error getting orders:', error);
-            return [];
-        }
-    }
-
-    async reconnect() {
-        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
-            this.debug('Max reconnection attempts reached');
-            return false;
-        }
-
-        this.reconnectAttempts++;
-        const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
-        this.debug(`Reconnecting in ${delay}ms... (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
-        
-        await new Promise(resolve => setTimeout(resolve, delay));
-        return this.initialize();
-    }
-
-    subscribe(eventName, callback) {
-        if (!this.subscribers.has(eventName)) {
-            this.subscribers.set(eventName, new Set());
-        }
-        this.subscribers.get(eventName).add(callback);
-    }
-
-    unsubscribe(eventName, callback) {
-        if (this.subscribers.has(eventName)) {
-            this.subscribers.get(eventName).delete(callback);
-        }
-    }
-
-    // Example method to listen to contract events
-    listenToContractEvents(contract, eventName) {
-        if (!this.provider) {
-            throw new Error('WebSocket not initialized');
-        }
-
-        contract.on(eventName, (...args) => {
-            const event = args[args.length - 1]; // Last argument is the event object
-            const subscribers = this.subscribers.get(eventName);
-            if (subscribers) {
-                subscribers.forEach(callback => callback(event));
-            }
-        });
-    }
-
-    updateOrderCache(orderId, orderData) {
-        this.orderCache.set(orderId, orderData);
-    }
-
-    removeOrder(orderId) {
-        this.orderCache.delete(orderId);
-    }
-
-    removeOrders(orderIds) {
-        if (!Array.isArray(orderIds)) {
-            console.warn('[WebSocket] removeOrders called with non-array:', orderIds);
-            return;
-        }
-        
-        this.debug('Removing orders:', orderIds);
-        orderIds.forEach(orderId => {
-            this.orderCache.delete(orderId);
-        });
-        
-        // Notify subscribers of the update
-        this.notifySubscribers('ordersUpdated', this.getOrders());
-    }
-
-    notifySubscribers(eventName, data) {
-        this.debug('Notifying subscribers for event:', eventName);
-        const subscribers = this.subscribers.get(eventName);
-        if (subscribers) {
-            this.debug('Found', subscribers.size, 'subscribers');
-            subscribers.forEach(callback => {
-                try {
-                    this.debug('Calling subscriber callback');
-                    callback(data);
-                    this.debug('Subscriber callback completed');
-                } catch (error) {
-                    this.debug('Error in subscriber callback:', error);
-                }
-            });
-        } else {
-            this.debug('No subscribers found for event:', eventName);
-        }
-    }
-
-    async checkContractState(contract) {
-        try {
-            // Get deployer/owner address
-            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
-            const currentAccount = accounts[0];
-            
-            this.debug('Contract state check:', {
-                address: contract.address,
-                currentAccount,
-                bytecodeExists: await contract.provider.getCode(contract.address) !== '0x'
-            });
-            
-            return true;
-        } catch (error) {
-            this.debug('Contract state check failed:', error);
-            return false;
-        }
-    }
-
-    // Add this method to verify specific order state
-    async verifyOrderState(orderId) {
-        try {
-            const order = await this.contract.orders(orderId);
-            this.debug('Direct order state check:', {
-                orderId,
-                exists: order.maker !== ethers.constants.AddressZero,
-                status: ['Active', 'Filled', 'Canceled'][order.status],
-                timestamp: order.timestamp.toNumber()
-            });
-            return order;
-        } catch (error) {
-            this.debug('Error verifying order state:', error);
-            return null;
-        }
-    }
-
-    // Add this method to check if orders are eligible for cleanup
-    async checkCleanupEligibility(orderId) {
-        try {
-            if (!this.contract) {
-                throw new Error('Contract not initialized');
-            }
-
-            const order = this.orderCache.get(orderId);
-            if (!order) {
-                this.debug('Order not found in cache:', orderId);
-                return { isEligible: false };
-            }
-
-            const orderExpiry = await this.contract.ORDER_EXPIRY();
-            const gracePeriod = await this.contract.GRACE_PERIOD();
-
-            const currentTime = Math.floor(Date.now() / 1000);
-            const orderTime = order.timestamp;
-            const age = currentTime - orderTime;
-            
-            // Consider both active and cancelled orders that are past expiry + grace period
-            const isEligible = (order.status === 'Active' || order.status === 'Canceled') && 
-                              age > (orderExpiry.toNumber() + gracePeriod.toNumber());
-
-            this.debug('Cleanup eligibility check:', {
-                orderId,
-                orderTime,
-                currentTime,
-                age,
-                orderExpiry: orderExpiry.toNumber(),
-                gracePeriod: gracePeriod.toNumber(),
-                status: order.status,
-                isEligible
-            });
-
-            return {
-                isEligible,
-                order
-            };
-        } catch (error) {
-            this.debug('Error checking cleanup eligibility:', error);
-            return { isEligible: false, error };
-        }
-    }
-}
diff --git a/otc/js/utils/ethereum.js b/otc/js/utils/ethereum.js
deleted file mode 100644
index e69de29..0000000
diff --git a/otc/js/utils/ui.js b/otc/js/utils/ui.js
deleted file mode 100644
index e69de29..0000000
diff --git a/tokenfaucet/index.html b/tokenfaucet/index.html
deleted file mode 100644
index e062e7f..0000000
--- a/tokenfaucet/index.html
+++ /dev/null
@@ -1,210 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-  <head>
-    <meta charset="UTF-8" />
-    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
-    <title>Test Token Faucet</title>
-    
-    <script type="importmap">
-      {
-        "imports": {
-          "ethers": "https://unpkg.com/ethers@5.7.2/dist/ethers.esm.min.js"
-        }
-      }
-    </script>
-
-    <style>
-        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
-
-        :root {
-            --gb-dark: #8B4513;    /* Saddle Brown */
-            --gb-medium: #CD853F;  /* Peru */
-            --gb-light: #DEB887;   /* Burlywood */
-            --gb-lightest: #FFE4B5; /* Moccasin */
-        }
-
-        body {
-            font-family: 'Press Start 2P', cursive;
-            background-color: var(--gb-dark);
-            color: var(--gb-lightest);
-            margin: 0;
-            min-height: 100vh;
-            display: flex;
-            justify-content: center;
-            align-items: center;
-            font-size: 14px;
-            line-height: 1.5;
-        }
-
-        .container {
-            text-align: center;
-            padding: 2rem;
-            background-color: var(--gb-medium);
-            border: 8px solid var(--gb-light);
-            border-radius: 20px;
-            box-shadow: inset 0 0 10px var(--gb-dark);
-            max-width: 90%;
-            width: 400px;
-        }
-
-        h1 {
-            color: var(--gb-lightest);
-            margin-bottom: 1.5rem;
-            font-size: 1.2rem;
-        }
-
-        p {
-            margin-bottom: 2rem;
-            font-size: 0.8rem;
-        }
-
-        .addresses {
-            font-size: 12px;
-            margin: 20px 0;
-            word-break: break-all;
-            color: var(--gb-lightest);
-        }
-
-        .address-label {
-            color: var(--gb-lightest);
-            opacity: 0.8;
-            margin-top: 10px;
-        }
-
-        button {
-            background-color: var(--gb-dark);
-            color: var(--gb-lightest);
-            border: 4px solid var(--gb-light);
-            padding: 12px 24px;
-            margin: 10px;
-            cursor: pointer;
-            font-family: 'Press Start 2P', cursive;
-            font-size: 0.8rem;
-            transition: all 0.2s ease;
-        }
-
-        button:hover:not(:disabled) {
-            background-color: var(--gb-light);
-            color: var(--gb-dark);
-            transform: scale(1.05);
-        }
-
-        button:active:not(:disabled) {
-            transform: scale(0.95);
-        }
-
-        button:disabled {
-            opacity: 0.5;
-            cursor: not-allowed;
-        }
-
-        #status {
-            margin-top: 20px;
-            padding: 10px;
-            border-radius: 5px;
-            font-size: 0.7rem;
-        }
-
-        .success {
-            background-color: var(--gb-light);
-            color: var(--gb-dark);
-        }
-
-        .error {
-            background-color: var(--gb-dark);
-            color: var(--gb-lightest);
-        }
-    </style>
-
-    <script type="module">
-        import { ethers } from 'ethers';
-        
-        window.addEventListener('load', async () => {
-            const faucetAddress = '0x3730f410e91F146089325fbD23f49D9ef544964F';
-            const faucetABI = [
-                "function getTokens() external",
-                "function getSecondTokenAddress() external view returns (address)",
-                "event TokensDistributed(address indexed recipient, uint256 amount, address firstToken, address secondToken)"
-            ];
-
-            let provider;
-            let signer;
-            let contract;
-            let secondTokenContract;
-            
-            const connectButton = document.getElementById('connectButton');
-            const getTokensButton = document.getElementById('getTokensButton');
-            const statusDiv = document.getElementById('status');
-            const firstTokenAddress = document.getElementById('firstTokenAddress');
-            const secondTokenAddress = document.getElementById('secondTokenAddress');
-
-            async function connectWallet() {
-                try {
-                    if (typeof window.ethereum === 'undefined') {
-                        throw new Error('Please install MetaMask to use this dApp');
-                    }
-                    await window.ethereum.request({ method: 'eth_requestAccounts' });
-                    provider = new ethers.providers.Web3Provider(window.ethereum);
-                    signer = provider.getSigner();
-                    contract = new ethers.Contract(faucetAddress, faucetABI, signer);
-
-                    // Display first token address (faucet address)
-                    firstTokenAddress.textContent = faucetAddress;
-
-                    // Get and display second token address
-                    const secondAddress = await contract.getSecondTokenAddress();
-                    secondTokenAddress.textContent = secondAddress;
-
-                    const address = await signer.getAddress();
-                    connectButton.textContent = `Connected: ${address.substring(0, 6)}...${address.substring(38)}`;
-                    getTokensButton.disabled = false;
-
-                    showStatus('Wallet connected successfully!', 'success');
-                } catch (error) {
-                    showStatus(`Error: ${error.message}`, 'error');
-                }
-            }
-
-            async function getTokens() {
-                try {
-                    getTokensButton.disabled = true;
-                    showStatus("Transaction pending...", "success");
-
-                    const tx = await contract.getTokens();
-                    await tx.wait();
-
-                    showStatus("Tokens received successfully!", "success");
-                } catch (error) {
-                    showStatus(`Error: ${error.message}`, "error");
-                } finally {
-                    getTokensButton.disabled = false;
-                }
-            }
-
-            function showStatus(message, type) {
-                statusDiv.textContent = message;
-                statusDiv.className = type;
-                statusDiv.style.display = 'block';
-            }
-
-            connectButton.addEventListener('click', connectWallet);
-            getTokensButton.addEventListener('click', getTokens);
-        });
-    </script>
-  </head>
-  <body>
-    <div class="container">
-        <h1>Test Token Faucet</h1>
-        <p>CONNECT WALLET TO CONTINUE</p>
-        <div class="addresses">
-            <div class="address-label">First Token:</div>
-            <div id="firstTokenAddress">Connect wallet to view</div>
-            <div class="address-label">Second Token:</div>
-            <div id="secondTokenAddress">Connect wallet to view</div>
-        </div>
-        <button id="connectButton">Connect Wallet</button>
-        <button id="getTokensButton" disabled>Get Tokens</button>
-        <div id="status" style="display: none;"></div>
-    </div>
-  </body>
-</html>
